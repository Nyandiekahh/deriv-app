{"version":3,"file":"js/core.3020.78973846415b1162ad96.js","mappings":"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","sources":["webpack:///../../shared/node_modules/js-cookie/src/js.cookie.js","webpack:///../../utils/node_modules/@deriv-com/auth-client/dist/constants/urls.js","webpack:///../../utils/node_modules/@deriv-com/auth-client/dist/js.cookie-OLEfuq_g.js","webpack:///../../utils/node_modules/@deriv-com/auth-client/dist/oidc/error.js","webpack:///../../utils/node_modules/@deriv-com/auth-client/dist/oidc/oidc.js","webpack:///../../utils/node_modules/@deriv-com/auth-client/dist/jsx-runtime-B6kdoens.js","webpack:///../../utils/node_modules/@deriv-com/auth-client/dist/tmb/error.js","webpack:///../../utils/node_modules/@deriv-com/auth-client/dist/tmb/tmb.js"],"sourcesContent":["/*!\n * JavaScript Cookie v2.2.1\n * https://github.com/js-cookie/js-cookie\n *\n * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n * Released under the MIT license\n */\n;(function (factory) {\n\tvar registeredInModuleLoader;\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(factory);\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (typeof exports === 'object') {\n\t\tmodule.exports = factory();\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (!registeredInModuleLoader) {\n\t\tvar OldCookies = window.Cookies;\n\t\tvar api = window.Cookies = factory();\n\t\tapi.noConflict = function () {\n\t\t\twindow.Cookies = OldCookies;\n\t\t\treturn api;\n\t\t};\n\t}\n}(function () {\n\tfunction extend () {\n\t\tvar i = 0;\n\t\tvar result = {};\n\t\tfor (; i < arguments.length; i++) {\n\t\t\tvar attributes = arguments[ i ];\n\t\t\tfor (var key in attributes) {\n\t\t\t\tresult[key] = attributes[key];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction decode (s) {\n\t\treturn s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);\n\t}\n\n\tfunction init (converter) {\n\t\tfunction api() {}\n\n\t\tfunction set (key, value, attributes) {\n\t\t\tif (typeof document === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tattributes = extend({\n\t\t\t\tpath: '/'\n\t\t\t}, api.defaults, attributes);\n\n\t\t\tif (typeof attributes.expires === 'number') {\n\t\t\t\tattributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);\n\t\t\t}\n\n\t\t\t// We're using \"expires\" because \"max-age\" is not supported by IE\n\t\t\tattributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';\n\n\t\t\ttry {\n\t\t\t\tvar result = JSON.stringify(value);\n\t\t\t\tif (/^[\\{\\[]/.test(result)) {\n\t\t\t\t\tvalue = result;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\n\t\t\tvalue = converter.write ?\n\t\t\t\tconverter.write(value, key) :\n\t\t\t\tencodeURIComponent(String(value))\n\t\t\t\t\t.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\n\n\t\t\tkey = encodeURIComponent(String(key))\n\t\t\t\t.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)\n\t\t\t\t.replace(/[\\(\\)]/g, escape);\n\n\t\t\tvar stringifiedAttributes = '';\n\t\t\tfor (var attributeName in attributes) {\n\t\t\t\tif (!attributes[attributeName]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstringifiedAttributes += '; ' + attributeName;\n\t\t\t\tif (attributes[attributeName] === true) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Considers RFC 6265 section 5.2:\n\t\t\t\t// ...\n\t\t\t\t// 3.  If the remaining unparsed-attributes contains a %x3B (\";\")\n\t\t\t\t//     character:\n\t\t\t\t// Consume the characters of the unparsed-attributes up to,\n\t\t\t\t// not including, the first %x3B (\";\") character.\n\t\t\t\t// ...\n\t\t\t\tstringifiedAttributes += '=' + attributes[attributeName].split(';')[0];\n\t\t\t}\n\n\t\t\treturn (document.cookie = key + '=' + value + stringifiedAttributes);\n\t\t}\n\n\t\tfunction get (key, json) {\n\t\t\tif (typeof document === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar jar = {};\n\t\t\t// To prevent the for loop in the first place assign an empty array\n\t\t\t// in case there are no cookies at all.\n\t\t\tvar cookies = document.cookie ? document.cookie.split('; ') : [];\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i < cookies.length; i++) {\n\t\t\t\tvar parts = cookies[i].split('=');\n\t\t\t\tvar cookie = parts.slice(1).join('=');\n\n\t\t\t\tif (!json && cookie.charAt(0) === '\"') {\n\t\t\t\t\tcookie = cookie.slice(1, -1);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tvar name = decode(parts[0]);\n\t\t\t\t\tcookie = (converter.read || converter)(cookie, name) ||\n\t\t\t\t\t\tdecode(cookie);\n\n\t\t\t\t\tif (json) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcookie = JSON.parse(cookie);\n\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t}\n\n\t\t\t\t\tjar[name] = cookie;\n\n\t\t\t\t\tif (key === name) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\treturn key ? jar[key] : jar;\n\t\t}\n\n\t\tapi.set = set;\n\t\tapi.get = function (key) {\n\t\t\treturn get(key, false /* read as raw */);\n\t\t};\n\t\tapi.getJSON = function (key) {\n\t\t\treturn get(key, true /* read as json */);\n\t\t};\n\t\tapi.remove = function (key, attributes) {\n\t\t\tset(key, '', extend(attributes, {\n\t\t\t\texpires: -1\n\t\t\t}));\n\t\t};\n\n\t\tapi.defaults = {};\n\n\t\tapi.withConverter = init;\n\n\t\treturn api;\n\t}\n\n\treturn init(function () {});\n}));\n","import { URLConstants as a, LocalStorageUtils as o, LocalStorageConstants as r, AppIDConstants as U, URLUtils as h, WebSocketUtils as v } from \"@deriv-com/utils\";\nconst I = \"https://oauth.deriv.com/oauth2/sessions/logout\", L = \"https://oauth.deriv.com\", m = {\n  [a.derivP2pProduction]: \"blue.derivws.com\",\n  [a.derivP2pStaging]: \"red.derivws.com\"\n}, c = () => {\n  const e = window.location.origin, t = window.location.hostname, { getAppId: n } = v, l = n(), g = o.getValue(r.configAppId), u = o.getValue(r.configServerURL);\n  e === a.derivP2pStaging && (!g || !u) && (o.setValue(\n    r.configServerURL,\n    m[e]\n  ), o.setValue(\n    r.configAppId,\n    `${U.domainAppId[t]}`\n  ));\n  const i = o.getValue(r.configServerURL) || localStorage.getItem(\"config.server_url\");\n  let s = \"oauth.deriv.com\";\n  i && /qa/.test(String(i)) ? s = i : t.includes(\".deriv.me\") ? s = \"oauth.deriv.me\" : t.includes(\".deriv.be\") && (s = \"oauth.deriv.be\");\n  const p = o.getValue(r.configAppId) || l, d = o.getValue(r.i18nLanguage);\n  return {\n    appId: p,\n    lang: d,\n    serverUrl: s\n  };\n}, f = () => {\n  const { appId: e, lang: t, serverUrl: n } = c();\n  return e && n ? `https://${n}/oauth2/authorize?app_id=${e}&l=${t ?? \"EN\"}&brand=deriv` : h.getOauthURL();\n}, A = () => {\n  const { appId: e, serverUrl: t } = c();\n  return e && t ? `https://${t}/oauth2/sessions/logout` : I;\n}, O = () => {\n  const { appId: e, serverUrl: t } = c();\n  return e && t ? `https://${t}` : L;\n};\nexport {\n  I as DEFAULT_OAUTH_LOGOUT_URL,\n  L as DEFAULT_OAUTH_ORIGIN_URL,\n  A as getOAuthLogoutUrl,\n  O as getOAuthOrigin,\n  f as getOauthUrl,\n  c as getServerInfo\n};\n","/*! js-cookie v3.0.5 | MIT */\nfunction d(r) {\n  for (var c = 1; c < arguments.length; c++) {\n    var f = arguments[c];\n    for (var p in f)\n      r[p] = f[p];\n  }\n  return r;\n}\nvar g = {\n  read: function(r) {\n    return r[0] === '\"' && (r = r.slice(1, -1)), r.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent);\n  },\n  write: function(r) {\n    return encodeURIComponent(r).replace(\n      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,\n      decodeURIComponent\n    );\n  }\n};\nfunction s(r, c) {\n  function f(n, t, e) {\n    if (!(typeof document > \"u\")) {\n      e = d({}, c, e), typeof e.expires == \"number\" && (e.expires = new Date(Date.now() + e.expires * 864e5)), e.expires && (e.expires = e.expires.toUTCString()), n = encodeURIComponent(n).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);\n      var o = \"\";\n      for (var i in e)\n        e[i] && (o += \"; \" + i, e[i] !== !0 && (o += \"=\" + e[i].split(\";\")[0]));\n      return document.cookie = n + \"=\" + r.write(t, n) + o;\n    }\n  }\n  function p(n) {\n    if (!(typeof document > \"u\" || arguments.length && !n)) {\n      for (var t = document.cookie ? document.cookie.split(\"; \") : [], e = {}, o = 0; o < t.length; o++) {\n        var i = t[o].split(\"=\"), v = i.slice(1).join(\"=\");\n        try {\n          var u = decodeURIComponent(i[0]);\n          if (e[u] = r.read(v, u), n === u)\n            break;\n        } catch {\n        }\n      }\n      return n ? e[n] : e;\n    }\n  }\n  return Object.create(\n    {\n      set: f,\n      get: p,\n      remove: function(n, t) {\n        f(\n          n,\n          \"\",\n          d({}, t, {\n            expires: -1\n          })\n        );\n      },\n      withAttributes: function(n) {\n        return s(this.converter, d({}, this.attributes, n));\n      },\n      withConverter: function(n) {\n        return s(d({}, this.converter, n), this.attributes);\n      }\n    },\n    {\n      attributes: { value: Object.freeze(c) },\n      converter: { value: Object.freeze(r) }\n    }\n  );\n}\nvar a = s(g, { path: \"/\" });\nexport {\n  a\n};\n","var t = Object.defineProperty;\nvar o = (e, i, a) => i in e ? t(e, i, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[i] = a;\nvar s = (e, i, a) => o(e, typeof i != \"symbol\" ? i + \"\" : i, a);\nvar d = /* @__PURE__ */ ((e) => (e.FailedToFetchOIDCConfiguration = \"FailedToFetchOIDCConfiguration\", e.AuthenticationRequestFailed = \"AuthenticationRequestFailed\", e.AccessTokenRequestFailed = \"AccessTokenRequestFailed\", e.LegacyTokenRequestFailed = \"LegacyTokenRequestFailed\", e.RevokeTokenRequestFailed = \"RevokeTokenRequestFailed\", e.UserManagerCreationFailed = \"UserManagerCreationFailed\", e.OneTimeCodeMissing = \"OneTimeCodeMissing\", e.FailedToRemoveSession = \"FailedToRemoveSession\", e))(d || {});\nclass l extends Error {\n  constructor(a, n) {\n    super(n);\n    s(this, \"type\");\n    this.name = a, this.type = a;\n  }\n}\nexport {\n  l as OIDCError,\n  d as OIDCErrorType\n};\n","import { OIDCError as S, OIDCErrorType as w } from \"./error.js\";\nimport { getServerInfo as M, getOAuthLogoutUrl as Pe } from \"../constants/urls.js\";\nimport { getConfigurations as xe } from \"./config.js\";\nimport { a as le } from \"../js.cookie-OLEfuq_g.js\";\nclass $ extends Error {\n}\n$.prototype.name = \"InvalidTokenError\";\nfunction Oe(e) {\n  return decodeURIComponent(atob(e).replace(/(.)/g, (t, s) => {\n    let i = s.charCodeAt(0).toString(16).toUpperCase();\n    return i.length < 2 && (i = \"0\" + i), \"%\" + i;\n  }));\n}\nfunction Ae(e) {\n  let t = e.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  switch (t.length % 4) {\n    case 0:\n      break;\n    case 2:\n      t += \"==\";\n      break;\n    case 3:\n      t += \"=\";\n      break;\n    default:\n      throw new Error(\"base64 string is not of the correct length\");\n  }\n  try {\n    return Oe(t);\n  } catch {\n    return atob(t);\n  }\n}\nfunction qe(e, t) {\n  if (typeof e != \"string\")\n    throw new $(\"Invalid token specified: must be a string\");\n  t || (t = {});\n  const s = t.header === !0 ? 0 : 1, i = e.split(\".\")[s];\n  if (typeof i != \"string\")\n    throw new $(`Invalid token specified: missing part #${s + 1}`);\n  let r;\n  try {\n    r = Ae(i);\n  } catch (o) {\n    throw new $(`Invalid token specified: invalid base64 for part #${s + 1} (${o.message})`);\n  }\n  try {\n    return JSON.parse(r);\n  } catch (o) {\n    throw new $(`Invalid token specified: invalid json for part #${s + 1} (${o.message})`);\n  }\n}\nvar Ne = {\n  debug: () => {\n  },\n  info: () => {\n  },\n  warn: () => {\n  },\n  error: () => {\n  }\n}, E, T, L = /* @__PURE__ */ ((e) => (e[e.NONE = 0] = \"NONE\", e[e.ERROR = 1] = \"ERROR\", e[e.WARN = 2] = \"WARN\", e[e.INFO = 3] = \"INFO\", e[e.DEBUG = 4] = \"DEBUG\", e))(L || {});\n((e) => {\n  function t() {\n    E = 3, T = Ne;\n  }\n  e.reset = t;\n  function s(r) {\n    if (!(0 <= r && r <= 4))\n      throw new Error(\"Invalid log level\");\n    E = r;\n  }\n  e.setLevel = s;\n  function i(r) {\n    T = r;\n  }\n  e.setLogger = i;\n})(L || (L = {}));\nvar h = class k {\n  constructor(t) {\n    this._name = t;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  debug(...t) {\n    E >= 4 && T.debug(k._format(this._name, this._method), ...t);\n  }\n  info(...t) {\n    E >= 3 && T.info(k._format(this._name, this._method), ...t);\n  }\n  warn(...t) {\n    E >= 2 && T.warn(k._format(this._name, this._method), ...t);\n  }\n  error(...t) {\n    E >= 1 && T.error(k._format(this._name, this._method), ...t);\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n  throw(t) {\n    throw this.error(t), t;\n  }\n  create(t) {\n    const s = Object.create(this);\n    return s._method = t, s.debug(\"begin\"), s;\n  }\n  static createStatic(t, s) {\n    const i = new k(`${t}.${s}`);\n    return i.debug(\"begin\"), i;\n  }\n  static _format(t, s) {\n    const i = `[${t}]`;\n    return s ? `${i} ${s}:` : i;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  // helpers for static class methods\n  static debug(t, ...s) {\n    E >= 4 && T.debug(k._format(t), ...s);\n  }\n  static info(t, ...s) {\n    E >= 3 && T.info(k._format(t), ...s);\n  }\n  static warn(t, ...s) {\n    E >= 2 && T.warn(k._format(t), ...s);\n  }\n  static error(t, ...s) {\n    E >= 1 && T.error(k._format(t), ...s);\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n};\nL.reset();\nvar F = class {\n  // IMPORTANT: doesn't validate the token\n  static decode(e) {\n    try {\n      return qe(e);\n    } catch (t) {\n      throw h.error(\"JwtUtils.decode\", t), t;\n    }\n  }\n  static async generateSignedJwt(e, t, s) {\n    const i = f.encodeBase64Url(new TextEncoder().encode(JSON.stringify(e))), r = f.encodeBase64Url(new TextEncoder().encode(JSON.stringify(t))), o = `${i}.${r}`, n = await window.crypto.subtle.sign(\n      {\n        name: \"ECDSA\",\n        hash: { name: \"SHA-256\" }\n      },\n      s,\n      new TextEncoder().encode(o)\n    ), a = f.encodeBase64Url(new Uint8Array(n));\n    return `${o}.${a}`;\n  }\n}, Me = \"10000000-1000-4000-8000-100000000000\", B = (e) => btoa([...new Uint8Array(e)].map((t) => String.fromCharCode(t)).join(\"\")), de = class b {\n  static _randomWord() {\n    const t = new Uint32Array(1);\n    return crypto.getRandomValues(t), t[0];\n  }\n  /**\n   * Generates RFC4122 version 4 guid\n   */\n  static generateUUIDv4() {\n    return Me.replace(\n      /[018]/g,\n      (s) => (+s ^ b._randomWord() & 15 >> +s / 4).toString(16)\n    ).replace(/-/g, \"\");\n  }\n  /**\n   * PKCE: Generate a code verifier\n   */\n  static generateCodeVerifier() {\n    return b.generateUUIDv4() + b.generateUUIDv4() + b.generateUUIDv4();\n  }\n  /**\n   * PKCE: Generate a code challenge\n   */\n  static async generateCodeChallenge(t) {\n    if (!crypto.subtle)\n      throw new Error(\"Crypto.subtle is available only in secure contexts (HTTPS).\");\n    try {\n      const i = new TextEncoder().encode(t), r = await crypto.subtle.digest(\"SHA-256\", i);\n      return B(r).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    } catch (s) {\n      throw h.error(\"CryptoUtils.generateCodeChallenge\", s), s;\n    }\n  }\n  /**\n   * Generates a base64-encoded string for a basic auth header\n   */\n  static generateBasicAuth(t, s) {\n    const r = new TextEncoder().encode([t, s].join(\":\"));\n    return B(r);\n  }\n  /**\n   * Generates a hash of a string using a given algorithm\n   * @param alg\n   * @param message\n   */\n  static async hash(t, s) {\n    const i = new TextEncoder().encode(s), r = await crypto.subtle.digest(t, i);\n    return new Uint8Array(r);\n  }\n  /**\n   * Generates a rfc7638 compliant jwk thumbprint\n   * @param jwk\n   */\n  static async customCalculateJwkThumbprint(t) {\n    let s;\n    switch (t.kty) {\n      case \"RSA\":\n        s = {\n          e: t.e,\n          kty: t.kty,\n          n: t.n\n        };\n        break;\n      case \"EC\":\n        s = {\n          crv: t.crv,\n          kty: t.kty,\n          x: t.x,\n          y: t.y\n        };\n        break;\n      case \"OKP\":\n        s = {\n          crv: t.crv,\n          kty: t.kty,\n          x: t.x\n        };\n        break;\n      case \"oct\":\n        s = {\n          crv: t.k,\n          kty: t.kty\n        };\n        break;\n      default:\n        throw new Error(\"Unknown jwk type\");\n    }\n    const i = await b.hash(\"SHA-256\", JSON.stringify(s));\n    return b.encodeBase64Url(i);\n  }\n  static async generateDPoPProof({\n    url: t,\n    accessToken: s,\n    httpMethod: i,\n    keyPair: r,\n    nonce: o\n  }) {\n    let n, a;\n    const c = {\n      jti: window.crypto.randomUUID(),\n      htm: i ?? \"GET\",\n      htu: t,\n      iat: Math.floor(Date.now() / 1e3)\n    };\n    s && (n = await b.hash(\"SHA-256\", s), a = b.encodeBase64Url(n), c.ath = a), o && (c.nonce = o);\n    try {\n      const l = await crypto.subtle.exportKey(\"jwk\", r.publicKey), d = {\n        alg: \"ES256\",\n        typ: \"dpop+jwt\",\n        jwk: {\n          crv: l.crv,\n          kty: l.kty,\n          x: l.x,\n          y: l.y\n        }\n      };\n      return await F.generateSignedJwt(d, c, r.privateKey);\n    } catch (l) {\n      throw l instanceof TypeError ? new Error(`Error exporting dpop public key: ${l.message}`) : l;\n    }\n  }\n  static async generateDPoPJkt(t) {\n    try {\n      const s = await crypto.subtle.exportKey(\"jwk\", t.publicKey);\n      return await b.customCalculateJwkThumbprint(s);\n    } catch (s) {\n      throw s instanceof TypeError ? new Error(`Could not retrieve dpop keys from storage: ${s.message}`) : s;\n    }\n  }\n  static async generateDPoPKeys() {\n    return await window.crypto.subtle.generateKey(\n      {\n        name: \"ECDSA\",\n        namedCurve: \"P-256\"\n      },\n      !1,\n      [\"sign\", \"verify\"]\n    );\n  }\n};\nde.encodeBase64Url = (e) => B(e).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\nvar f = de, P = class {\n  constructor(e) {\n    this._name = e, this._callbacks = [], this._logger = new h(`Event('${this._name}')`);\n  }\n  addHandler(e) {\n    return this._callbacks.push(e), () => this.removeHandler(e);\n  }\n  removeHandler(e) {\n    const t = this._callbacks.lastIndexOf(e);\n    t >= 0 && this._callbacks.splice(t, 1);\n  }\n  async raise(...e) {\n    this._logger.debug(\"raise:\", ...e);\n    for (const t of this._callbacks)\n      await t(...e);\n  }\n}, ne = class {\n  /**\n   * Populates a map of window features with a placement centered in front of\n   * the current window. If no explicit width is given, a default value is\n   * binned into [800, 720, 600, 480, 360] based on the current window's width.\n   */\n  static center({ ...e }) {\n    var t, s, i;\n    return e.width == null && (e.width = (t = [800, 720, 600, 480].find((r) => r <= window.outerWidth / 1.618)) != null ? t : 360), (s = e.left) != null || (e.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - e.width) / 2))), e.height != null && ((i = e.top) != null || (e.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - e.height) / 2)))), e;\n  }\n  static serialize(e) {\n    return Object.entries(e).filter(([, t]) => t != null).map(([t, s]) => `${t}=${typeof s != \"boolean\" ? s : s ? \"yes\" : \"no\"}`).join(\",\");\n  }\n}, R = class J extends P {\n  constructor() {\n    super(...arguments), this._logger = new h(`Timer('${this._name}')`), this._timerHandle = null, this._expiration = 0, this._callback = () => {\n      const t = this._expiration - J.getEpochTime();\n      this._logger.debug(\"timer completes in\", t), this._expiration <= J.getEpochTime() && (this.cancel(), super.raise());\n    };\n  }\n  // get the time\n  static getEpochTime() {\n    return Math.floor(Date.now() / 1e3);\n  }\n  init(t) {\n    const s = this._logger.create(\"init\");\n    t = Math.max(Math.floor(t), 1);\n    const i = J.getEpochTime() + t;\n    if (this.expiration === i && this._timerHandle) {\n      s.debug(\"skipping since already initialized for expiration at\", this.expiration);\n      return;\n    }\n    this.cancel(), s.debug(\"using duration\", t), this._expiration = i;\n    const r = Math.min(t, 5);\n    this._timerHandle = setInterval(this._callback, r * 1e3);\n  }\n  get expiration() {\n    return this._expiration;\n  }\n  cancel() {\n    this._logger.create(\"cancel\"), this._timerHandle && (clearInterval(this._timerHandle), this._timerHandle = null);\n  }\n}, V = class {\n  static readParams(e, t = \"query\") {\n    if (!e) throw new TypeError(\"Invalid URL\");\n    const i = new URL(e, \"http://127.0.0.1\")[t === \"fragment\" ? \"hash\" : \"search\"];\n    return new URLSearchParams(i.slice(1));\n  }\n}, Q = \";\", D = class extends Error {\n  constructor(e, t) {\n    var s, i, r;\n    if (super(e.error_description || e.error || \"\"), this.form = t, this.name = \"ErrorResponse\", !e.error)\n      throw h.error(\"ErrorResponse\", \"No error passed\"), new Error(\"No error passed\");\n    this.error = e.error, this.error_description = (s = e.error_description) != null ? s : null, this.error_uri = (i = e.error_uri) != null ? i : null, this.state = e.userState, this.session_state = (r = e.session_state) != null ? r : null, this.url_state = e.url_state;\n  }\n}, ee = class extends Error {\n  constructor(e) {\n    super(e), this.name = \"ErrorTimeout\";\n  }\n}, De = class {\n  constructor(e) {\n    this._logger = new h(\"AccessTokenEvents\"), this._expiringTimer = new R(\"Access token expiring\"), this._expiredTimer = new R(\"Access token expired\"), this._expiringNotificationTimeInSeconds = e.expiringNotificationTimeInSeconds;\n  }\n  load(e) {\n    const t = this._logger.create(\"load\");\n    if (e.access_token && e.expires_in !== void 0) {\n      const s = e.expires_in;\n      if (t.debug(\"access token present, remaining duration:\", s), s > 0) {\n        let r = s - this._expiringNotificationTimeInSeconds;\n        r <= 0 && (r = 1), t.debug(\"registering expiring timer, raising in\", r, \"seconds\"), this._expiringTimer.init(r);\n      } else\n        t.debug(\"canceling existing expiring timer because we're past expiration.\"), this._expiringTimer.cancel();\n      const i = s + 1;\n      t.debug(\"registering expired timer, raising in\", i, \"seconds\"), this._expiredTimer.init(i);\n    } else\n      this._expiringTimer.cancel(), this._expiredTimer.cancel();\n  }\n  unload() {\n    this._logger.debug(\"unload: canceling existing access token timers\"), this._expiringTimer.cancel(), this._expiredTimer.cancel();\n  }\n  /**\n   * Add callback: Raised prior to the access token expiring.\n   */\n  addAccessTokenExpiring(e) {\n    return this._expiringTimer.addHandler(e);\n  }\n  /**\n   * Remove callback: Raised prior to the access token expiring.\n   */\n  removeAccessTokenExpiring(e) {\n    this._expiringTimer.removeHandler(e);\n  }\n  /**\n   * Add callback: Raised after the access token has expired.\n   */\n  addAccessTokenExpired(e) {\n    return this._expiredTimer.addHandler(e);\n  }\n  /**\n   * Remove callback: Raised after the access token has expired.\n   */\n  removeAccessTokenExpired(e) {\n    this._expiredTimer.removeHandler(e);\n  }\n}, je = class {\n  constructor(e, t, s, i, r) {\n    this._callback = e, this._client_id = t, this._intervalInSeconds = i, this._stopOnError = r, this._logger = new h(\"CheckSessionIFrame\"), this._timer = null, this._session_state = null, this._message = (n) => {\n      n.origin === this._frame_origin && n.source === this._frame.contentWindow && (n.data === \"error\" ? (this._logger.error(\"error message from check session op iframe\"), this._stopOnError && this.stop()) : n.data === \"changed\" ? (this._logger.debug(\"changed message from check session op iframe\"), this.stop(), this._callback()) : this._logger.debug(n.data + \" message from check session op iframe\"));\n    };\n    const o = new URL(s);\n    this._frame_origin = o.origin, this._frame = window.document.createElement(\"iframe\"), this._frame.style.visibility = \"hidden\", this._frame.style.position = \"fixed\", this._frame.style.left = \"-1000px\", this._frame.style.top = \"0\", this._frame.width = \"0\", this._frame.height = \"0\", this._frame.src = o.href;\n  }\n  load() {\n    return new Promise((e) => {\n      this._frame.onload = () => {\n        e();\n      }, window.document.body.appendChild(this._frame), window.addEventListener(\"message\", this._message, !1);\n    });\n  }\n  start(e) {\n    if (this._session_state === e)\n      return;\n    this._logger.create(\"start\"), this.stop(), this._session_state = e;\n    const t = () => {\n      !this._frame.contentWindow || !this._session_state || this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n    };\n    t(), this._timer = setInterval(t, this._intervalInSeconds * 1e3);\n  }\n  stop() {\n    this._logger.create(\"stop\"), this._session_state = null, this._timer && (clearInterval(this._timer), this._timer = null);\n  }\n}, ge = class {\n  constructor() {\n    this._logger = new h(\"InMemoryWebStorage\"), this._data = {};\n  }\n  clear() {\n    this._logger.create(\"clear\"), this._data = {};\n  }\n  getItem(e) {\n    return this._logger.create(`getItem('${e}')`), this._data[e];\n  }\n  setItem(e, t) {\n    this._logger.create(`setItem('${e}')`), this._data[e] = t;\n  }\n  removeItem(e) {\n    this._logger.create(`removeItem('${e}')`), delete this._data[e];\n  }\n  get length() {\n    return Object.getOwnPropertyNames(this._data).length;\n  }\n  key(e) {\n    return Object.getOwnPropertyNames(this._data)[e];\n  }\n}, G = class extends Error {\n  constructor(e, t) {\n    super(t), this.name = \"ErrorDPoPNonce\", this.nonce = e;\n  }\n}, te = class {\n  constructor(e = [], t = null, s = {}) {\n    this._jwtHandler = t, this._extraHeaders = s, this._logger = new h(\"JsonService\"), this._contentTypes = [], this._contentTypes.push(...e, \"application/json\"), t && this._contentTypes.push(\"application/jwt\");\n  }\n  async fetchWithTimeout(e, t = {}) {\n    const { timeoutInSeconds: s, ...i } = t;\n    if (!s)\n      return await fetch(e, i);\n    const r = new AbortController(), o = setTimeout(() => r.abort(), s * 1e3);\n    try {\n      return await fetch(e, {\n        ...t,\n        signal: r.signal\n      });\n    } catch (n) {\n      throw n instanceof DOMException && n.name === \"AbortError\" ? new ee(\"Network timed out\") : n;\n    } finally {\n      clearTimeout(o);\n    }\n  }\n  async getJson(e, {\n    token: t,\n    credentials: s,\n    timeoutInSeconds: i\n  } = {}) {\n    const r = this._logger.create(\"getJson\"), o = {\n      Accept: this._contentTypes.join(\", \")\n    };\n    t && (r.debug(\"token passed, setting Authorization header\"), o.Authorization = \"Bearer \" + t), this.appendExtraHeaders(o);\n    let n;\n    try {\n      r.debug(\"url:\", e), n = await this.fetchWithTimeout(e, { method: \"GET\", headers: o, timeoutInSeconds: i, credentials: s });\n    } catch (l) {\n      throw r.error(\"Network Error\"), l;\n    }\n    r.debug(\"HTTP response received, status\", n.status);\n    const a = n.headers.get(\"Content-Type\");\n    if (a && !this._contentTypes.find((l) => a.startsWith(l)) && r.throw(new Error(`Invalid response Content-Type: ${a ?? \"undefined\"}, from URL: ${e}`)), n.ok && this._jwtHandler && (a != null && a.startsWith(\"application/jwt\")))\n      return await this._jwtHandler(await n.text());\n    let c;\n    try {\n      c = await n.json();\n    } catch (l) {\n      throw r.error(\"Error parsing JSON response\", l), n.ok ? l : new Error(`${n.statusText} (${n.status})`);\n    }\n    if (!n.ok)\n      throw r.error(\"Error from server:\", c), c.error ? new D(c) : new Error(`${n.statusText} (${n.status}): ${JSON.stringify(c)}`);\n    return c;\n  }\n  async postForm(e, {\n    body: t,\n    basicAuth: s,\n    timeoutInSeconds: i,\n    initCredentials: r,\n    extraHeaders: o\n  }) {\n    const n = this._logger.create(\"postForm\"), a = {\n      Accept: this._contentTypes.join(\", \"),\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n      ...o\n    };\n    s !== void 0 && (a.Authorization = \"Basic \" + s), this.appendExtraHeaders(a);\n    let c;\n    try {\n      n.debug(\"url:\", e), c = await this.fetchWithTimeout(e, { method: \"POST\", headers: a, body: t, timeoutInSeconds: i, credentials: r });\n    } catch (u) {\n      throw n.error(\"Network error\"), u;\n    }\n    n.debug(\"HTTP response received, status\", c.status);\n    const l = c.headers.get(\"Content-Type\");\n    if (l && !this._contentTypes.find((u) => l.startsWith(u)))\n      throw new Error(`Invalid response Content-Type: ${l ?? \"undefined\"}, from URL: ${e}`);\n    const d = await c.text();\n    let g = {};\n    if (d)\n      try {\n        g = JSON.parse(d);\n      } catch (u) {\n        throw n.error(\"Error parsing JSON response\", u), c.ok ? u : new Error(`${c.statusText} (${c.status})`);\n      }\n    if (!c.ok) {\n      if (n.error(\"Error from server:\", g), c.headers.has(\"dpop-nonce\")) {\n        const u = c.headers.get(\"dpop-nonce\");\n        throw new G(u, `${JSON.stringify(g)}`);\n      }\n      throw g.error ? new D(g, t) : new Error(`${c.statusText} (${c.status}): ${JSON.stringify(g)}`);\n    }\n    return g;\n  }\n  appendExtraHeaders(e) {\n    const t = this._logger.create(\"appendExtraHeaders\"), s = Object.keys(this._extraHeaders), i = [\n      \"authorization\",\n      \"accept\",\n      \"content-type\"\n    ];\n    s.length !== 0 && s.forEach((r) => {\n      if (i.includes(r.toLocaleLowerCase())) {\n        t.warn(\"Protected header could not be overridden\", r, i);\n        return;\n      }\n      const o = typeof this._extraHeaders[r] == \"function\" ? this._extraHeaders[r]() : this._extraHeaders[r];\n      o && o !== \"\" && (e[r] = o);\n    });\n  }\n}, $e = class {\n  constructor(e) {\n    this._settings = e, this._logger = new h(\"MetadataService\"), this._signingKeys = null, this._metadata = null, this._metadataUrl = this._settings.metadataUrl, this._jsonService = new te(\n      [\"application/jwk-set+json\"],\n      null,\n      this._settings.extraHeaders\n    ), this._settings.signingKeys && (this._logger.debug(\"using signingKeys from settings\"), this._signingKeys = this._settings.signingKeys), this._settings.metadata && (this._logger.debug(\"using metadata from settings\"), this._metadata = this._settings.metadata), this._settings.fetchRequestCredentials && (this._logger.debug(\"using fetchRequestCredentials from settings\"), this._fetchRequestCredentials = this._settings.fetchRequestCredentials);\n  }\n  resetSigningKeys() {\n    this._signingKeys = null;\n  }\n  async getMetadata() {\n    const e = this._logger.create(\"getMetadata\");\n    if (this._metadata)\n      return e.debug(\"using cached values\"), this._metadata;\n    if (!this._metadataUrl)\n      throw e.throw(new Error(\"No authority or metadataUrl configured on settings\")), null;\n    e.debug(\"getting metadata from\", this._metadataUrl);\n    const t = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials, timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n    return e.debug(\"merging remote JSON with seed metadata\"), this._metadata = Object.assign({}, this._settings.metadataSeed, t), this._metadata;\n  }\n  getIssuer() {\n    return this._getMetadataProperty(\"issuer\");\n  }\n  getAuthorizationEndpoint() {\n    return this._getMetadataProperty(\"authorization_endpoint\");\n  }\n  getUserInfoEndpoint() {\n    return this._getMetadataProperty(\"userinfo_endpoint\");\n  }\n  getTokenEndpoint(e = !0) {\n    return this._getMetadataProperty(\"token_endpoint\", e);\n  }\n  getCheckSessionIframe() {\n    return this._getMetadataProperty(\"check_session_iframe\", !0);\n  }\n  getEndSessionEndpoint() {\n    return this._getMetadataProperty(\"end_session_endpoint\", !0);\n  }\n  getRevocationEndpoint(e = !0) {\n    return this._getMetadataProperty(\"revocation_endpoint\", e);\n  }\n  getKeysEndpoint(e = !0) {\n    return this._getMetadataProperty(\"jwks_uri\", e);\n  }\n  async _getMetadataProperty(e, t = !1) {\n    const s = this._logger.create(`_getMetadataProperty('${e}')`), i = await this.getMetadata();\n    if (s.debug(\"resolved\"), i[e] === void 0) {\n      if (t === !0) {\n        s.warn(\"Metadata does not contain optional property\");\n        return;\n      }\n      s.throw(new Error(\"Metadata does not contain property \" + e));\n    }\n    return i[e];\n  }\n  async getSigningKeys() {\n    const e = this._logger.create(\"getSigningKeys\");\n    if (this._signingKeys)\n      return e.debug(\"returning signingKeys from cache\"), this._signingKeys;\n    const t = await this.getKeysEndpoint(!1);\n    e.debug(\"got jwks_uri\", t);\n    const s = await this._jsonService.getJson(t, { timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n    if (e.debug(\"got key set\", s), !Array.isArray(s.keys))\n      throw e.throw(new Error(\"Missing keys on keyset\")), null;\n    return this._signingKeys = s.keys, this._signingKeys;\n  }\n}, se = class {\n  constructor({\n    prefix: e = \"oidc.\",\n    store: t = localStorage\n  } = {}) {\n    this._logger = new h(\"WebStorageStateStore\"), this._store = t, this._prefix = e;\n  }\n  async set(e, t) {\n    this._logger.create(`set('${e}')`), e = this._prefix + e, await this._store.setItem(e, t);\n  }\n  async get(e) {\n    return this._logger.create(`get('${e}')`), e = this._prefix + e, await this._store.getItem(e);\n  }\n  async remove(e) {\n    this._logger.create(`remove('${e}')`), e = this._prefix + e;\n    const t = await this._store.getItem(e);\n    return await this._store.removeItem(e), t;\n  }\n  async getAllKeys() {\n    this._logger.create(\"getAllKeys\");\n    const e = await this._store.length, t = [];\n    for (let s = 0; s < e; s++) {\n      const i = await this._store.key(s);\n      i && i.indexOf(this._prefix) === 0 && t.push(i.substr(this._prefix.length));\n    }\n    return t;\n  }\n}, He = \"code\", Je = \"openid\", Le = \"client_secret_post\", Fe = 60 * 15, X = class {\n  constructor({\n    // metadata related\n    authority: e,\n    metadataUrl: t,\n    metadata: s,\n    signingKeys: i,\n    metadataSeed: r,\n    // client related\n    client_id: o,\n    client_secret: n,\n    response_type: a = He,\n    scope: c = Je,\n    redirect_uri: l,\n    post_logout_redirect_uri: d,\n    client_authentication: g = Le,\n    // optional protocol\n    prompt: u,\n    display: p,\n    max_age: x,\n    ui_locales: O,\n    acr_values: A,\n    resource: q,\n    response_mode: U,\n    // behavior flags\n    filterProtocolClaims: C = !0,\n    loadUserInfo: N = !1,\n    requestTimeoutInSeconds: v,\n    staleStateAgeInSeconds: _ = Fe,\n    mergeClaimsStrategy: I = { array: \"replace\" },\n    disablePKCE: y = !1,\n    // other behavior\n    stateStore: m,\n    revokeTokenAdditionalContentTypes: H,\n    fetchRequestCredentials: ie,\n    refreshTokenAllowedScope: be,\n    // extra\n    extraQueryParams: Ee = {},\n    extraTokenParams: Te = {},\n    extraHeaders: Ie = {},\n    dpop: Re,\n    omitScopeWhenRequesting: Ue = !1\n  }) {\n    var re;\n    if (this.authority = e, t ? this.metadataUrl = t : (this.metadataUrl = e, e && (this.metadataUrl.endsWith(\"/\") || (this.metadataUrl += \"/\"), this.metadataUrl += \".well-known/openid-configuration\")), this.metadata = s, this.metadataSeed = r, this.signingKeys = i, this.client_id = o, this.client_secret = n, this.response_type = a, this.scope = c, this.redirect_uri = l, this.post_logout_redirect_uri = d, this.client_authentication = g, this.prompt = u, this.display = p, this.max_age = x, this.ui_locales = O, this.acr_values = A, this.resource = q, this.response_mode = U, this.filterProtocolClaims = C ?? !0, this.loadUserInfo = !!N, this.staleStateAgeInSeconds = _, this.mergeClaimsStrategy = I, this.omitScopeWhenRequesting = Ue, this.disablePKCE = !!y, this.revokeTokenAdditionalContentTypes = H, this.fetchRequestCredentials = ie || \"same-origin\", this.requestTimeoutInSeconds = v, m)\n      this.stateStore = m;\n    else {\n      const Ce = typeof window < \"u\" ? window.localStorage : new ge();\n      this.stateStore = new se({ store: Ce });\n    }\n    if (this.refreshTokenAllowedScope = be, this.extraQueryParams = Ee, this.extraTokenParams = Te, this.extraHeaders = Ie, this.dpop = Re, this.dpop && !((re = this.dpop) != null && re.store))\n      throw new Error(\"A DPoPStore is required when dpop is enabled\");\n  }\n}, We = class {\n  constructor(e, t) {\n    this._settings = e, this._metadataService = t, this._logger = new h(\"UserInfoService\"), this._getClaimsFromJwt = async (s) => {\n      const i = this._logger.create(\"_getClaimsFromJwt\");\n      try {\n        const r = F.decode(s);\n        return i.debug(\"JWT decoding successful\"), r;\n      } catch (r) {\n        throw i.error(\"Error parsing JWT response\"), r;\n      }\n    }, this._jsonService = new te(\n      void 0,\n      this._getClaimsFromJwt,\n      this._settings.extraHeaders\n    );\n  }\n  async getClaims(e) {\n    const t = this._logger.create(\"getClaims\");\n    e || this._logger.throw(new Error(\"No token passed\"));\n    const s = await this._metadataService.getUserInfoEndpoint();\n    t.debug(\"got userinfo url\", s);\n    const i = await this._jsonService.getJson(s, {\n      token: e,\n      credentials: this._settings.fetchRequestCredentials,\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds\n    });\n    return t.debug(\"got claims\", i), i;\n  }\n}, he = class {\n  constructor(e, t) {\n    this._settings = e, this._metadataService = t, this._logger = new h(\"TokenClient\"), this._jsonService = new te(\n      this._settings.revokeTokenAdditionalContentTypes,\n      null,\n      this._settings.extraHeaders\n    );\n  }\n  /**\n   * Exchange code.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n   */\n  async exchangeCode({\n    grant_type: e = \"authorization_code\",\n    redirect_uri: t = this._settings.redirect_uri,\n    client_id: s = this._settings.client_id,\n    client_secret: i = this._settings.client_secret,\n    extraHeaders: r,\n    ...o\n  }) {\n    const n = this._logger.create(\"exchangeCode\");\n    s || n.throw(new Error(\"A client_id is required\")), t || n.throw(new Error(\"A redirect_uri is required\")), o.code || n.throw(new Error(\"A code is required\"));\n    const a = new URLSearchParams({ grant_type: e, redirect_uri: t });\n    for (const [g, u] of Object.entries(o))\n      u != null && a.set(g, u);\n    let c;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!i)\n          throw n.throw(new Error(\"A client_secret is required\")), null;\n        c = f.generateBasicAuth(s, i);\n        break;\n      case \"client_secret_post\":\n        a.append(\"client_id\", s), i && a.append(\"client_secret\", i);\n        break;\n    }\n    const l = await this._metadataService.getTokenEndpoint(!1);\n    n.debug(\"got token endpoint\");\n    const d = await this._jsonService.postForm(l, {\n      body: a,\n      basicAuth: c,\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds,\n      initCredentials: this._settings.fetchRequestCredentials,\n      extraHeaders: r\n    });\n    return n.debug(\"got response\"), d;\n  }\n  /**\n   * Exchange credentials.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n   */\n  async exchangeCredentials({\n    grant_type: e = \"password\",\n    client_id: t = this._settings.client_id,\n    client_secret: s = this._settings.client_secret,\n    scope: i = this._settings.scope,\n    ...r\n  }) {\n    const o = this._logger.create(\"exchangeCredentials\");\n    t || o.throw(new Error(\"A client_id is required\"));\n    const n = new URLSearchParams({ grant_type: e });\n    this._settings.omitScopeWhenRequesting || n.set(\"scope\", i);\n    for (const [d, g] of Object.entries(r))\n      g != null && n.set(d, g);\n    let a;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!s)\n          throw o.throw(new Error(\"A client_secret is required\")), null;\n        a = f.generateBasicAuth(t, s);\n        break;\n      case \"client_secret_post\":\n        n.append(\"client_id\", t), s && n.append(\"client_secret\", s);\n        break;\n    }\n    const c = await this._metadataService.getTokenEndpoint(!1);\n    o.debug(\"got token endpoint\");\n    const l = await this._jsonService.postForm(c, { body: n, basicAuth: a, timeoutInSeconds: this._settings.requestTimeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n    return o.debug(\"got response\"), l;\n  }\n  /**\n   * Exchange a refresh token.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n   */\n  async exchangeRefreshToken({\n    grant_type: e = \"refresh_token\",\n    client_id: t = this._settings.client_id,\n    client_secret: s = this._settings.client_secret,\n    timeoutInSeconds: i,\n    extraHeaders: r,\n    ...o\n  }) {\n    const n = this._logger.create(\"exchangeRefreshToken\");\n    t || n.throw(new Error(\"A client_id is required\")), o.refresh_token || n.throw(new Error(\"A refresh_token is required\"));\n    const a = new URLSearchParams({ grant_type: e });\n    for (const [g, u] of Object.entries(o))\n      Array.isArray(u) ? u.forEach((p) => a.append(g, p)) : u != null && a.set(g, u);\n    let c;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!s)\n          throw n.throw(new Error(\"A client_secret is required\")), null;\n        c = f.generateBasicAuth(t, s);\n        break;\n      case \"client_secret_post\":\n        a.append(\"client_id\", t), s && a.append(\"client_secret\", s);\n        break;\n    }\n    const l = await this._metadataService.getTokenEndpoint(!1);\n    n.debug(\"got token endpoint\");\n    const d = await this._jsonService.postForm(l, { body: a, basicAuth: c, timeoutInSeconds: i, initCredentials: this._settings.fetchRequestCredentials, extraHeaders: r });\n    return n.debug(\"got response\"), d;\n  }\n  /**\n   * Revoke an access or refresh token.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n   */\n  async revoke(e) {\n    var t;\n    const s = this._logger.create(\"revoke\");\n    e.token || s.throw(new Error(\"A token is required\"));\n    const i = await this._metadataService.getRevocationEndpoint(!1);\n    s.debug(`got revocation endpoint, revoking ${(t = e.token_type_hint) != null ? t : \"default token type\"}`);\n    const r = new URLSearchParams();\n    for (const [o, n] of Object.entries(e))\n      n != null && r.set(o, n);\n    r.set(\"client_id\", this._settings.client_id), this._settings.client_secret && r.set(\"client_secret\", this._settings.client_secret), await this._jsonService.postForm(i, { body: r, timeoutInSeconds: this._settings.requestTimeoutInSeconds }), s.debug(\"got response\");\n  }\n}, Ke = class {\n  constructor(e, t, s) {\n    this._settings = e, this._metadataService = t, this._claimsService = s, this._logger = new h(\"ResponseValidator\"), this._userInfoService = new We(this._settings, this._metadataService), this._tokenClient = new he(this._settings, this._metadataService);\n  }\n  async validateSigninResponse(e, t, s) {\n    const i = this._logger.create(\"validateSigninResponse\");\n    this._processSigninState(e, t), i.debug(\"state processed\"), await this._processCode(e, t, s), i.debug(\"code processed\"), e.isOpenId && this._validateIdTokenAttributes(e), i.debug(\"tokens validated\"), await this._processClaims(e, t == null ? void 0 : t.skipUserInfo, e.isOpenId), i.debug(\"claims processed\");\n  }\n  async validateCredentialsResponse(e, t) {\n    const s = this._logger.create(\"validateCredentialsResponse\");\n    e.isOpenId && e.id_token && this._validateIdTokenAttributes(e), s.debug(\"tokens validated\"), await this._processClaims(e, t, e.isOpenId), s.debug(\"claims processed\");\n  }\n  async validateRefreshResponse(e, t) {\n    var s, i;\n    const r = this._logger.create(\"validateRefreshResponse\");\n    e.userState = t.data, (s = e.session_state) != null || (e.session_state = t.session_state), (i = e.scope) != null || (e.scope = t.scope), e.isOpenId && e.id_token && (this._validateIdTokenAttributes(e, t.id_token), r.debug(\"ID Token validated\")), e.id_token || (e.id_token = t.id_token, e.profile = t.profile);\n    const o = e.isOpenId && !!e.id_token;\n    await this._processClaims(e, !1, o), r.debug(\"claims processed\");\n  }\n  validateSignoutResponse(e, t) {\n    const s = this._logger.create(\"validateSignoutResponse\");\n    if (t.id !== e.state && s.throw(new Error(\"State does not match\")), s.debug(\"state validated\"), e.userState = t.data, e.error)\n      throw s.warn(\"Response was error\", e.error), new D(e);\n  }\n  _processSigninState(e, t) {\n    var s;\n    const i = this._logger.create(\"_processSigninState\");\n    if (t.id !== e.state && i.throw(new Error(\"State does not match\")), t.client_id || i.throw(new Error(\"No client_id on state\")), t.authority || i.throw(new Error(\"No authority on state\")), this._settings.authority !== t.authority && i.throw(new Error(\"authority mismatch on settings vs. signin state\")), this._settings.client_id && this._settings.client_id !== t.client_id && i.throw(new Error(\"client_id mismatch on settings vs. signin state\")), i.debug(\"state validated\"), e.userState = t.data, e.url_state = t.url_state, (s = e.scope) != null || (e.scope = t.scope), e.error)\n      throw i.warn(\"Response was error\", e.error), new D(e);\n    t.code_verifier && !e.code && i.throw(new Error(\"Expected code in response\"));\n  }\n  async _processClaims(e, t = !1, s = !0) {\n    const i = this._logger.create(\"_processClaims\");\n    if (e.profile = this._claimsService.filterProtocolClaims(e.profile), t || !this._settings.loadUserInfo || !e.access_token) {\n      i.debug(\"not loading user info\");\n      return;\n    }\n    i.debug(\"loading user info\");\n    const r = await this._userInfoService.getClaims(e.access_token);\n    i.debug(\"user info claims received from user info endpoint\"), s && r.sub !== e.profile.sub && i.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\")), e.profile = this._claimsService.mergeClaims(e.profile, this._claimsService.filterProtocolClaims(r)), i.debug(\"user info claims received, updated profile:\", e.profile);\n  }\n  async _processCode(e, t, s) {\n    const i = this._logger.create(\"_processCode\");\n    if (e.code) {\n      i.debug(\"Validating code\");\n      const r = await this._tokenClient.exchangeCode({\n        client_id: t.client_id,\n        client_secret: t.client_secret,\n        code: e.code,\n        redirect_uri: t.redirect_uri,\n        code_verifier: t.code_verifier,\n        extraHeaders: s,\n        ...t.extraTokenParams\n      });\n      Object.assign(e, r);\n    } else\n      i.debug(\"No code to process\");\n  }\n  _validateIdTokenAttributes(e, t) {\n    var s;\n    const i = this._logger.create(\"_validateIdTokenAttributes\");\n    i.debug(\"decoding ID Token JWT\");\n    const r = F.decode((s = e.id_token) != null ? s : \"\");\n    if (r.sub || i.throw(new Error(\"ID Token is missing a subject claim\")), t) {\n      const o = F.decode(t);\n      r.sub !== o.sub && i.throw(new Error(\"sub in id_token does not match current sub\")), r.auth_time && r.auth_time !== o.auth_time && i.throw(new Error(\"auth_time in id_token does not match original auth_time\")), r.azp && r.azp !== o.azp && i.throw(new Error(\"azp in id_token does not match original azp\")), !r.azp && o.azp && i.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n    }\n    e.profile = r;\n  }\n}, W = class Y {\n  constructor(t) {\n    this.id = t.id || f.generateUUIDv4(), this.data = t.data, t.created && t.created > 0 ? this.created = t.created : this.created = R.getEpochTime(), this.request_type = t.request_type, this.url_state = t.url_state;\n  }\n  toStorageString() {\n    return new h(\"State\").create(\"toStorageString\"), JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state\n    });\n  }\n  static fromStorageString(t) {\n    return h.createStatic(\"State\", \"fromStorageString\"), Promise.resolve(new Y(JSON.parse(t)));\n  }\n  static async clearStaleState(t, s) {\n    const i = h.createStatic(\"State\", \"clearStaleState\"), r = R.getEpochTime() - s, o = await t.getAllKeys();\n    i.debug(\"got keys\", o);\n    for (let n = 0; n < o.length; n++) {\n      const a = o[n], c = await t.get(a);\n      let l = !1;\n      if (c)\n        try {\n          const d = await Y.fromStorageString(c);\n          i.debug(\"got item from key:\", a, d.created), d.created <= r && (l = !0);\n        } catch (d) {\n          i.error(\"Error parsing state for key:\", a, d), l = !0;\n        }\n      else\n        i.debug(\"no item in storage for key:\", a), l = !0;\n      l && (i.debug(\"removed item for key:\", a), t.remove(a));\n    }\n  }\n}, ue = class Z extends W {\n  constructor(t) {\n    super(t), this.code_verifier = t.code_verifier, this.code_challenge = t.code_challenge, this.authority = t.authority, this.client_id = t.client_id, this.redirect_uri = t.redirect_uri, this.scope = t.scope, this.client_secret = t.client_secret, this.extraTokenParams = t.extraTokenParams, this.response_mode = t.response_mode, this.skipUserInfo = t.skipUserInfo;\n  }\n  static async create(t) {\n    const s = t.code_verifier === !0 ? f.generateCodeVerifier() : t.code_verifier || void 0, i = s ? await f.generateCodeChallenge(s) : void 0;\n    return new Z({\n      ...t,\n      code_verifier: s,\n      code_challenge: i\n    });\n  }\n  toStorageString() {\n    return new h(\"SigninState\").create(\"toStorageString\"), JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state,\n      code_verifier: this.code_verifier,\n      authority: this.authority,\n      client_id: this.client_id,\n      redirect_uri: this.redirect_uri,\n      scope: this.scope,\n      client_secret: this.client_secret,\n      extraTokenParams: this.extraTokenParams,\n      response_mode: this.response_mode,\n      skipUserInfo: this.skipUserInfo\n    });\n  }\n  static fromStorageString(t) {\n    h.createStatic(\"SigninState\", \"fromStorageString\");\n    const s = JSON.parse(t);\n    return Z.create(s);\n  }\n}, _e = class pe {\n  constructor(t) {\n    this.url = t.url, this.state = t.state;\n  }\n  static async create({\n    // mandatory\n    url: t,\n    authority: s,\n    client_id: i,\n    redirect_uri: r,\n    response_type: o,\n    scope: n,\n    // optional\n    state_data: a,\n    response_mode: c,\n    request_type: l,\n    client_secret: d,\n    nonce: g,\n    url_state: u,\n    resource: p,\n    skipUserInfo: x,\n    extraQueryParams: O,\n    extraTokenParams: A,\n    disablePKCE: q,\n    dpopJkt: U,\n    omitScopeWhenRequesting: C,\n    ...N\n  }) {\n    if (!t)\n      throw this._logger.error(\"create: No url passed\"), new Error(\"url\");\n    if (!i)\n      throw this._logger.error(\"create: No client_id passed\"), new Error(\"client_id\");\n    if (!r)\n      throw this._logger.error(\"create: No redirect_uri passed\"), new Error(\"redirect_uri\");\n    if (!o)\n      throw this._logger.error(\"create: No response_type passed\"), new Error(\"response_type\");\n    if (!n)\n      throw this._logger.error(\"create: No scope passed\"), new Error(\"scope\");\n    if (!s)\n      throw this._logger.error(\"create: No authority passed\"), new Error(\"authority\");\n    const v = await ue.create({\n      data: a,\n      request_type: l,\n      url_state: u,\n      code_verifier: !q,\n      client_id: i,\n      authority: s,\n      redirect_uri: r,\n      response_mode: c,\n      client_secret: d,\n      scope: n,\n      extraTokenParams: A,\n      skipUserInfo: x\n    }), _ = new URL(t);\n    _.searchParams.append(\"client_id\", i), _.searchParams.append(\"redirect_uri\", r), _.searchParams.append(\"response_type\", o), C || _.searchParams.append(\"scope\", n), g && _.searchParams.append(\"nonce\", g), U && _.searchParams.append(\"dpop_jkt\", U);\n    let I = v.id;\n    u && (I = `${I}${Q}${u}`), _.searchParams.append(\"state\", I), v.code_challenge && (_.searchParams.append(\"code_challenge\", v.code_challenge), _.searchParams.append(\"code_challenge_method\", \"S256\")), p && (Array.isArray(p) ? p : [p]).forEach((m) => _.searchParams.append(\"resource\", m));\n    for (const [y, m] of Object.entries({ response_mode: c, ...N, ...O }))\n      m != null && _.searchParams.append(y, m.toString());\n    return new pe({\n      url: _.href,\n      state: v\n    });\n  }\n};\n_e._logger = new h(\"SigninRequest\");\nvar ze = _e, Be = \"openid\", K = class {\n  constructor(e) {\n    if (this.access_token = \"\", this.token_type = \"\", this.profile = {}, this.state = e.get(\"state\"), this.session_state = e.get(\"session_state\"), this.state) {\n      const t = decodeURIComponent(this.state).split(Q);\n      this.state = t[0], t.length > 1 && (this.url_state = t.slice(1).join(Q));\n    }\n    this.error = e.get(\"error\"), this.error_description = e.get(\"error_description\"), this.error_uri = e.get(\"error_uri\"), this.code = e.get(\"code\");\n  }\n  get expires_in() {\n    if (this.expires_at !== void 0)\n      return this.expires_at - R.getEpochTime();\n  }\n  set expires_in(e) {\n    typeof e == \"string\" && (e = Number(e)), e !== void 0 && e >= 0 && (this.expires_at = Math.floor(e) + R.getEpochTime());\n  }\n  get isOpenId() {\n    var e;\n    return ((e = this.scope) == null ? void 0 : e.split(\" \").includes(Be)) || !!this.id_token;\n  }\n}, Ve = class {\n  constructor({\n    url: e,\n    state_data: t,\n    id_token_hint: s,\n    post_logout_redirect_uri: i,\n    extraQueryParams: r,\n    request_type: o,\n    client_id: n\n  }) {\n    if (this._logger = new h(\"SignoutRequest\"), !e)\n      throw this._logger.error(\"ctor: No url passed\"), new Error(\"url\");\n    const a = new URL(e);\n    s && a.searchParams.append(\"id_token_hint\", s), n && a.searchParams.append(\"client_id\", n), i && (a.searchParams.append(\"post_logout_redirect_uri\", i), t && (this.state = new W({ data: t, request_type: o }), a.searchParams.append(\"state\", this.state.id)));\n    for (const [c, l] of Object.entries({ ...r }))\n      l != null && a.searchParams.append(c, l.toString());\n    this.url = a.href;\n  }\n}, Qe = class {\n  constructor(e) {\n    this.state = e.get(\"state\"), this.error = e.get(\"error\"), this.error_description = e.get(\"error_description\"), this.error_uri = e.get(\"error_uri\");\n  }\n}, Ge = [\n  \"nbf\",\n  \"jti\",\n  \"auth_time\",\n  \"nonce\",\n  \"acr\",\n  \"amr\",\n  \"azp\",\n  \"at_hash\"\n  // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n], Xe = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"], Ye = class {\n  constructor(e) {\n    this._settings = e, this._logger = new h(\"ClaimsService\");\n  }\n  filterProtocolClaims(e) {\n    const t = { ...e };\n    if (this._settings.filterProtocolClaims) {\n      let s;\n      Array.isArray(this._settings.filterProtocolClaims) ? s = this._settings.filterProtocolClaims : s = Ge;\n      for (const i of s)\n        Xe.includes(i) || delete t[i];\n    }\n    return t;\n  }\n  mergeClaims(e, t) {\n    const s = { ...e };\n    for (const [i, r] of Object.entries(t))\n      if (s[i] !== r)\n        if (Array.isArray(s[i]) || Array.isArray(r))\n          if (this._settings.mergeClaimsStrategy.array == \"replace\")\n            s[i] = r;\n          else {\n            const o = Array.isArray(s[i]) ? s[i] : [s[i]];\n            for (const n of Array.isArray(r) ? r : [r])\n              o.includes(n) || o.push(n);\n            s[i] = o;\n          }\n        else typeof s[i] == \"object\" && typeof r == \"object\" ? s[i] = this.mergeClaims(s[i], r) : s[i] = r;\n    return s;\n  }\n}, fe = class {\n  constructor(e, t) {\n    this.keys = e, this.nonce = t;\n  }\n}, Ze = class {\n  constructor(e, t) {\n    this._logger = new h(\"OidcClient\"), this.settings = e instanceof X ? e : new X(e), this.metadataService = t ?? new $e(this.settings), this._claimsService = new Ye(this.settings), this._validator = new Ke(this.settings, this.metadataService, this._claimsService), this._tokenClient = new he(this.settings, this.metadataService);\n  }\n  async createSigninRequest({\n    state: e,\n    request: t,\n    request_uri: s,\n    request_type: i,\n    id_token_hint: r,\n    login_hint: o,\n    skipUserInfo: n,\n    nonce: a,\n    url_state: c,\n    response_type: l = this.settings.response_type,\n    scope: d = this.settings.scope,\n    redirect_uri: g = this.settings.redirect_uri,\n    prompt: u = this.settings.prompt,\n    display: p = this.settings.display,\n    max_age: x = this.settings.max_age,\n    ui_locales: O = this.settings.ui_locales,\n    acr_values: A = this.settings.acr_values,\n    resource: q = this.settings.resource,\n    response_mode: U = this.settings.response_mode,\n    extraQueryParams: C = this.settings.extraQueryParams,\n    extraTokenParams: N = this.settings.extraTokenParams,\n    dpopJkt: v,\n    omitScopeWhenRequesting: _ = this.settings.omitScopeWhenRequesting\n  }) {\n    const I = this._logger.create(\"createSigninRequest\");\n    if (l !== \"code\")\n      throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n    const y = await this.metadataService.getAuthorizationEndpoint();\n    I.debug(\"Received authorization endpoint\", y);\n    const m = await ze.create({\n      url: y,\n      authority: this.settings.authority,\n      client_id: this.settings.client_id,\n      redirect_uri: g,\n      response_type: l,\n      scope: d,\n      state_data: e,\n      url_state: c,\n      prompt: u,\n      display: p,\n      max_age: x,\n      ui_locales: O,\n      id_token_hint: r,\n      login_hint: o,\n      acr_values: A,\n      dpopJkt: v,\n      resource: q,\n      request: t,\n      request_uri: s,\n      extraQueryParams: C,\n      extraTokenParams: N,\n      request_type: i,\n      response_mode: U,\n      client_secret: this.settings.client_secret,\n      skipUserInfo: n,\n      nonce: a,\n      disablePKCE: this.settings.disablePKCE,\n      omitScopeWhenRequesting: _\n    });\n    await this.clearStaleState();\n    const H = m.state;\n    return await this.settings.stateStore.set(H.id, H.toStorageString()), m;\n  }\n  async readSigninResponseState(e, t = !1) {\n    const s = this._logger.create(\"readSigninResponseState\"), i = new K(V.readParams(e, this.settings.response_mode));\n    if (!i.state)\n      throw s.throw(new Error(\"No state in response\")), null;\n    const r = await this.settings.stateStore[t ? \"remove\" : \"get\"](i.state);\n    if (!r)\n      throw s.throw(new Error(\"No matching state found in storage\")), null;\n    return { state: await ue.fromStorageString(r), response: i };\n  }\n  async processSigninResponse(e, t) {\n    const s = this._logger.create(\"processSigninResponse\"), { state: i, response: r } = await this.readSigninResponseState(e, !0);\n    if (s.debug(\"received state from storage; validating response\"), this.settings.dpop && this.settings.dpop.store) {\n      const o = await this.getDpopProof(this.settings.dpop.store);\n      t = { ...t, DPoP: o };\n    }\n    try {\n      await this._validator.validateSigninResponse(r, i, t);\n    } catch (o) {\n      if (o instanceof G && this.settings.dpop) {\n        const n = await this.getDpopProof(this.settings.dpop.store, o.nonce);\n        t.DPoP = n, await this._validator.validateSigninResponse(r, i, t);\n      } else\n        throw o;\n    }\n    return r;\n  }\n  async getDpopProof(e, t) {\n    let s, i;\n    return (await e.getAllKeys()).includes(this.settings.client_id) ? (i = await e.get(this.settings.client_id), i.nonce !== t && t && (i.nonce = t, await e.set(this.settings.client_id, i))) : (s = await f.generateDPoPKeys(), i = new fe(s, t), await e.set(this.settings.client_id, i)), await f.generateDPoPProof({\n      url: await this.metadataService.getTokenEndpoint(!1),\n      httpMethod: \"POST\",\n      keyPair: i.keys,\n      nonce: i.nonce\n    });\n  }\n  async processResourceOwnerPasswordCredentials({\n    username: e,\n    password: t,\n    skipUserInfo: s = !1,\n    extraTokenParams: i = {}\n  }) {\n    const r = await this._tokenClient.exchangeCredentials({ username: e, password: t, ...i }), o = new K(new URLSearchParams());\n    return Object.assign(o, r), await this._validator.validateCredentialsResponse(o, s), o;\n  }\n  async useRefreshToken({\n    state: e,\n    redirect_uri: t,\n    resource: s,\n    timeoutInSeconds: i,\n    extraHeaders: r,\n    extraTokenParams: o\n  }) {\n    var n;\n    const a = this._logger.create(\"useRefreshToken\");\n    let c;\n    if (this.settings.refreshTokenAllowedScope === void 0)\n      c = e.scope;\n    else {\n      const g = this.settings.refreshTokenAllowedScope.split(\" \");\n      c = (((n = e.scope) == null ? void 0 : n.split(\" \")) || []).filter((p) => g.includes(p)).join(\" \");\n    }\n    if (this.settings.dpop && this.settings.dpop.store) {\n      const g = await this.getDpopProof(this.settings.dpop.store);\n      r = { ...r, DPoP: g };\n    }\n    let l;\n    try {\n      l = await this._tokenClient.exchangeRefreshToken({\n        refresh_token: e.refresh_token,\n        // provide the (possible filtered) scope list\n        scope: c,\n        redirect_uri: t,\n        resource: s,\n        timeoutInSeconds: i,\n        extraHeaders: r,\n        ...o\n      });\n    } catch (g) {\n      if (g instanceof G && this.settings.dpop)\n        r.DPoP = await this.getDpopProof(this.settings.dpop.store, g.nonce), l = await this._tokenClient.exchangeRefreshToken({\n          refresh_token: e.refresh_token,\n          // provide the (possible filtered) scope list\n          scope: c,\n          redirect_uri: t,\n          resource: s,\n          timeoutInSeconds: i,\n          extraHeaders: r,\n          ...o\n        });\n      else\n        throw g;\n    }\n    const d = new K(new URLSearchParams());\n    return Object.assign(d, l), a.debug(\"validating response\", d), await this._validator.validateRefreshResponse(d, {\n      ...e,\n      // override the scope in the state handed over to the validator\n      // so it can set the granted scope to the requested scope in case none is included in the response\n      scope: c\n    }), d;\n  }\n  async createSignoutRequest({\n    state: e,\n    id_token_hint: t,\n    client_id: s,\n    request_type: i,\n    post_logout_redirect_uri: r = this.settings.post_logout_redirect_uri,\n    extraQueryParams: o = this.settings.extraQueryParams\n  } = {}) {\n    const n = this._logger.create(\"createSignoutRequest\"), a = await this.metadataService.getEndSessionEndpoint();\n    if (!a)\n      throw n.throw(new Error(\"No end session endpoint\")), null;\n    n.debug(\"Received end session endpoint\", a), !s && r && !t && (s = this.settings.client_id);\n    const c = new Ve({\n      url: a,\n      id_token_hint: t,\n      client_id: s,\n      post_logout_redirect_uri: r,\n      state_data: e,\n      extraQueryParams: o,\n      request_type: i\n    });\n    await this.clearStaleState();\n    const l = c.state;\n    return l && (n.debug(\"Signout request has state to persist\"), await this.settings.stateStore.set(l.id, l.toStorageString())), c;\n  }\n  async readSignoutResponseState(e, t = !1) {\n    const s = this._logger.create(\"readSignoutResponseState\"), i = new Qe(V.readParams(e, this.settings.response_mode));\n    if (!i.state) {\n      if (s.debug(\"No state in response\"), i.error)\n        throw s.warn(\"Response was error:\", i.error), new D(i);\n      return { state: void 0, response: i };\n    }\n    const r = await this.settings.stateStore[t ? \"remove\" : \"get\"](i.state);\n    if (!r)\n      throw s.throw(new Error(\"No matching state found in storage\")), null;\n    return { state: await W.fromStorageString(r), response: i };\n  }\n  async processSignoutResponse(e) {\n    const t = this._logger.create(\"processSignoutResponse\"), { state: s, response: i } = await this.readSignoutResponseState(e, !0);\n    return s ? (t.debug(\"Received state from storage; validating response\"), this._validator.validateSignoutResponse(i, s)) : t.debug(\"No state from storage; skipping response validation\"), i;\n  }\n  clearStaleState() {\n    return this._logger.create(\"clearStaleState\"), W.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n  }\n  async revokeToken(e, t) {\n    return this._logger.create(\"revokeToken\"), await this._tokenClient.revoke({\n      token: e,\n      token_type_hint: t\n    });\n  }\n}, et = class {\n  constructor(e) {\n    this._userManager = e, this._logger = new h(\"SessionMonitor\"), this._start = async (t) => {\n      const s = t.session_state;\n      if (!s)\n        return;\n      const i = this._logger.create(\"_start\");\n      if (t.profile ? (this._sub = t.profile.sub, i.debug(\"session_state\", s, \", sub\", this._sub)) : (this._sub = void 0, i.debug(\"session_state\", s, \", anonymous user\")), this._checkSessionIFrame) {\n        this._checkSessionIFrame.start(s);\n        return;\n      }\n      try {\n        const r = await this._userManager.metadataService.getCheckSessionIframe();\n        if (r) {\n          i.debug(\"initializing check session iframe\");\n          const o = this._userManager.settings.client_id, n = this._userManager.settings.checkSessionIntervalInSeconds, a = this._userManager.settings.stopCheckSessionOnError, c = new je(this._callback, o, r, n, a);\n          await c.load(), this._checkSessionIFrame = c, c.start(s);\n        } else\n          i.warn(\"no check session iframe found in the metadata\");\n      } catch (r) {\n        i.error(\"Error from getCheckSessionIframe:\", r instanceof Error ? r.message : r);\n      }\n    }, this._stop = () => {\n      const t = this._logger.create(\"_stop\");\n      if (this._sub = void 0, this._checkSessionIFrame && this._checkSessionIFrame.stop(), this._userManager.settings.monitorAnonymousSession) {\n        const s = setInterval(async () => {\n          clearInterval(s);\n          try {\n            const i = await this._userManager.querySessionStatus();\n            if (i) {\n              const r = {\n                session_state: i.session_state,\n                profile: i.sub ? {\n                  sub: i.sub\n                } : null\n              };\n              this._start(r);\n            }\n          } catch (i) {\n            t.error(\"error from querySessionStatus\", i instanceof Error ? i.message : i);\n          }\n        }, 1e3);\n      }\n    }, this._callback = async () => {\n      const t = this._logger.create(\"_callback\");\n      try {\n        const s = await this._userManager.querySessionStatus();\n        let i = !0;\n        s && this._checkSessionIFrame ? s.sub === this._sub ? (i = !1, this._checkSessionIFrame.start(s.session_state), t.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", s.session_state), await this._userManager.events._raiseUserSessionChanged()) : t.debug(\"different subject signed into OP\", s.sub) : t.debug(\"subject no longer signed into OP\"), i ? this._sub ? await this._userManager.events._raiseUserSignedOut() : await this._userManager.events._raiseUserSignedIn() : t.debug(\"no change in session detected, no event to raise\");\n      } catch (s) {\n        this._sub && (t.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", s), await this._userManager.events._raiseUserSignedOut());\n      }\n    }, e || this._logger.throw(new Error(\"No user manager passed\")), this._userManager.events.addUserLoaded(this._start), this._userManager.events.addUserUnloaded(this._stop), this._init().catch((t) => {\n      this._logger.error(t);\n    });\n  }\n  async _init() {\n    this._logger.create(\"_init\");\n    const e = await this._userManager.getUser();\n    if (e)\n      this._start(e);\n    else if (this._userManager.settings.monitorAnonymousSession) {\n      const t = await this._userManager.querySessionStatus();\n      if (t) {\n        const s = {\n          session_state: t.session_state,\n          profile: t.sub ? {\n            sub: t.sub\n          } : null\n        };\n        this._start(s);\n      }\n    }\n  }\n}, z = class we {\n  constructor(t) {\n    var s;\n    this.id_token = t.id_token, this.session_state = (s = t.session_state) != null ? s : null, this.access_token = t.access_token, this.refresh_token = t.refresh_token, this.token_type = t.token_type, this.scope = t.scope, this.profile = t.profile, this.expires_at = t.expires_at, this.state = t.userState, this.url_state = t.url_state;\n  }\n  /** Computed number of seconds the access token has remaining. */\n  get expires_in() {\n    if (this.expires_at !== void 0)\n      return this.expires_at - R.getEpochTime();\n  }\n  set expires_in(t) {\n    t !== void 0 && (this.expires_at = Math.floor(t) + R.getEpochTime());\n  }\n  /** Computed value indicating if the access token is expired. */\n  get expired() {\n    const t = this.expires_in;\n    if (t !== void 0)\n      return t <= 0;\n  }\n  /** Array representing the parsed values from the `scope`. */\n  get scopes() {\n    var t, s;\n    return (s = (t = this.scope) == null ? void 0 : t.split(\" \")) != null ? s : [];\n  }\n  toStorageString() {\n    return new h(\"User\").create(\"toStorageString\"), JSON.stringify({\n      id_token: this.id_token,\n      session_state: this.session_state,\n      access_token: this.access_token,\n      refresh_token: this.refresh_token,\n      token_type: this.token_type,\n      scope: this.scope,\n      profile: this.profile,\n      expires_at: this.expires_at\n    });\n  }\n  static fromStorageString(t) {\n    return h.createStatic(\"User\", \"fromStorageString\"), new we(JSON.parse(t));\n  }\n}, oe = \"oidc-client\", me = class {\n  constructor() {\n    this._abort = new P(\"Window navigation aborted\"), this._disposeHandlers = /* @__PURE__ */ new Set(), this._window = null;\n  }\n  async navigate(e) {\n    const t = this._logger.create(\"navigate\");\n    if (!this._window)\n      throw new Error(\"Attempted to navigate on a disposed window\");\n    t.debug(\"setting URL in window\"), this._window.location.replace(e.url);\n    const { url: s, keepOpen: i } = await new Promise((r, o) => {\n      const n = (a) => {\n        var c;\n        const l = a.data, d = (c = e.scriptOrigin) != null ? c : window.location.origin;\n        if (!(a.origin !== d || (l == null ? void 0 : l.source) !== oe)) {\n          try {\n            const g = V.readParams(l.url, e.response_mode).get(\"state\");\n            if (g || t.warn(\"no state found in response url\"), a.source !== this._window && g !== e.state)\n              return;\n          } catch {\n            this._dispose(), o(new Error(\"Invalid response from window\"));\n          }\n          r(l);\n        }\n      };\n      window.addEventListener(\"message\", n, !1), this._disposeHandlers.add(() => window.removeEventListener(\"message\", n, !1)), this._disposeHandlers.add(this._abort.addHandler((a) => {\n        this._dispose(), o(a);\n      }));\n    });\n    return t.debug(\"got response from window\"), this._dispose(), i || this.close(), { url: s };\n  }\n  _dispose() {\n    this._logger.create(\"_dispose\");\n    for (const e of this._disposeHandlers)\n      e();\n    this._disposeHandlers.clear();\n  }\n  static _notifyParent(e, t, s = !1, i = window.location.origin) {\n    e.postMessage({\n      source: oe,\n      url: t,\n      keepOpen: s\n    }, i);\n  }\n}, Se = {\n  location: !1,\n  toolbar: !1,\n  height: 640,\n  closePopupWindowAfterInSeconds: -1\n}, ve = \"_blank\", tt = 60, st = 2, ye = 10, it = class extends X {\n  constructor(e) {\n    const {\n      popup_redirect_uri: t = e.redirect_uri,\n      popup_post_logout_redirect_uri: s = e.post_logout_redirect_uri,\n      popupWindowFeatures: i = Se,\n      popupWindowTarget: r = ve,\n      redirectMethod: o = \"assign\",\n      redirectTarget: n = \"self\",\n      iframeNotifyParentOrigin: a = e.iframeNotifyParentOrigin,\n      iframeScriptOrigin: c = e.iframeScriptOrigin,\n      requestTimeoutInSeconds: l,\n      silent_redirect_uri: d = e.redirect_uri,\n      silentRequestTimeoutInSeconds: g,\n      automaticSilentRenew: u = !0,\n      validateSubOnSilentRenew: p = !0,\n      includeIdTokenInSilentRenew: x = !1,\n      monitorSession: O = !1,\n      monitorAnonymousSession: A = !1,\n      checkSessionIntervalInSeconds: q = st,\n      query_status_response_type: U = \"code\",\n      stopCheckSessionOnError: C = !0,\n      revokeTokenTypes: N = [\"access_token\", \"refresh_token\"],\n      revokeTokensOnSignout: v = !1,\n      includeIdTokenInSilentSignout: _ = !1,\n      accessTokenExpiringNotificationTimeInSeconds: I = tt,\n      userStore: y\n    } = e;\n    if (super(e), this.popup_redirect_uri = t, this.popup_post_logout_redirect_uri = s, this.popupWindowFeatures = i, this.popupWindowTarget = r, this.redirectMethod = o, this.redirectTarget = n, this.iframeNotifyParentOrigin = a, this.iframeScriptOrigin = c, this.silent_redirect_uri = d, this.silentRequestTimeoutInSeconds = g || l || ye, this.automaticSilentRenew = u, this.validateSubOnSilentRenew = p, this.includeIdTokenInSilentRenew = x, this.monitorSession = O, this.monitorAnonymousSession = A, this.checkSessionIntervalInSeconds = q, this.stopCheckSessionOnError = C, this.query_status_response_type = U, this.revokeTokenTypes = N, this.revokeTokensOnSignout = v, this.includeIdTokenInSilentSignout = _, this.accessTokenExpiringNotificationTimeInSeconds = I, y)\n      this.userStore = y;\n    else {\n      const m = typeof window < \"u\" ? window.sessionStorage : new ge();\n      this.userStore = new se({ store: m });\n    }\n  }\n}, ae = class ke extends me {\n  constructor({\n    silentRequestTimeoutInSeconds: t = ye\n  }) {\n    super(), this._logger = new h(\"IFrameWindow\"), this._timeoutInSeconds = t, this._frame = ke.createHiddenIframe(), this._window = this._frame.contentWindow;\n  }\n  static createHiddenIframe() {\n    const t = window.document.createElement(\"iframe\");\n    return t.style.visibility = \"hidden\", t.style.position = \"fixed\", t.style.left = \"-1000px\", t.style.top = \"0\", t.width = \"0\", t.height = \"0\", window.document.body.appendChild(t), t;\n  }\n  async navigate(t) {\n    this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n    const s = setTimeout(() => void this._abort.raise(new ee(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1e3);\n    return this._disposeHandlers.add(() => clearTimeout(s)), await super.navigate(t);\n  }\n  close() {\n    var t;\n    this._frame && (this._frame.parentNode && (this._frame.addEventListener(\"load\", (s) => {\n      var i;\n      const r = s.target;\n      (i = r.parentNode) == null || i.removeChild(r), this._abort.raise(new Error(\"IFrame removed from DOM\"));\n    }, !0), (t = this._frame.contentWindow) == null || t.location.replace(\"about:blank\")), this._frame = null), this._window = null;\n  }\n  static notifyParent(t, s) {\n    return super._notifyParent(window.parent, t, !1, s);\n  }\n}, rt = class {\n  constructor(e) {\n    this._settings = e, this._logger = new h(\"IFrameNavigator\");\n  }\n  async prepare({\n    silentRequestTimeoutInSeconds: e = this._settings.silentRequestTimeoutInSeconds\n  }) {\n    return new ae({ silentRequestTimeoutInSeconds: e });\n  }\n  async callback(e) {\n    this._logger.create(\"callback\"), ae.notifyParent(e, this._settings.iframeNotifyParentOrigin);\n  }\n}, nt = 500, ot = 1e3, ce = class extends me {\n  constructor({\n    popupWindowTarget: e = ve,\n    popupWindowFeatures: t = {},\n    popupSignal: s\n  }) {\n    super(), this._logger = new h(\"PopupWindow\");\n    const i = ne.center({ ...Se, ...t });\n    this._window = window.open(void 0, e, ne.serialize(i)), s && s.addEventListener(\"abort\", () => {\n      var r;\n      this._abort.raise(new Error((r = s.reason) != null ? r : \"Popup aborted\"));\n    }), t.closePopupWindowAfterInSeconds && t.closePopupWindowAfterInSeconds > 0 && setTimeout(() => {\n      if (!this._window || typeof this._window.closed != \"boolean\" || this._window.closed) {\n        this._abort.raise(new Error(\"Popup blocked by user\"));\n        return;\n      }\n      this.close();\n    }, t.closePopupWindowAfterInSeconds * ot);\n  }\n  async navigate(e) {\n    var t;\n    (t = this._window) == null || t.focus();\n    const s = setInterval(() => {\n      (!this._window || this._window.closed) && this._abort.raise(new Error(\"Popup closed by user\"));\n    }, nt);\n    return this._disposeHandlers.add(() => clearInterval(s)), await super.navigate(e);\n  }\n  close() {\n    this._window && (this._window.closed || (this._window.close(), this._abort.raise(new Error(\"Popup closed\")))), this._window = null;\n  }\n  static notifyOpener(e, t) {\n    if (!window.opener)\n      throw new Error(\"No window.opener. Can't complete notification.\");\n    return super._notifyParent(window.opener, e, t);\n  }\n}, at = class {\n  constructor(e) {\n    this._settings = e, this._logger = new h(\"PopupNavigator\");\n  }\n  async prepare({\n    popupWindowFeatures: e = this._settings.popupWindowFeatures,\n    popupWindowTarget: t = this._settings.popupWindowTarget,\n    popupSignal: s\n  }) {\n    return new ce({ popupWindowFeatures: e, popupWindowTarget: t, popupSignal: s });\n  }\n  async callback(e, { keepOpen: t = !1 }) {\n    this._logger.create(\"callback\"), ce.notifyOpener(e, t);\n  }\n}, ct = class {\n  constructor(e) {\n    this._settings = e, this._logger = new h(\"RedirectNavigator\");\n  }\n  async prepare({\n    redirectMethod: e = this._settings.redirectMethod,\n    redirectTarget: t = this._settings.redirectTarget\n  }) {\n    var s;\n    this._logger.create(\"prepare\");\n    let i = window.self;\n    t === \"top\" && (i = (s = window.top) != null ? s : window.self);\n    const r = i.location[e].bind(i.location);\n    let o;\n    return {\n      navigate: async (n) => {\n        this._logger.create(\"navigate\");\n        const a = new Promise((c, l) => {\n          o = l;\n        });\n        return r(n.url), await a;\n      },\n      close: () => {\n        this._logger.create(\"close\"), o == null || o(new Error(\"Redirect aborted\")), i.stop();\n      }\n    };\n  }\n  async callback() {\n  }\n}, lt = class extends De {\n  constructor(e) {\n    super({ expiringNotificationTimeInSeconds: e.accessTokenExpiringNotificationTimeInSeconds }), this._logger = new h(\"UserManagerEvents\"), this._userLoaded = new P(\"User loaded\"), this._userUnloaded = new P(\"User unloaded\"), this._silentRenewError = new P(\"Silent renew error\"), this._userSignedIn = new P(\"User signed in\"), this._userSignedOut = new P(\"User signed out\"), this._userSessionChanged = new P(\"User session changed\");\n  }\n  async load(e, t = !0) {\n    super.load(e), t && await this._userLoaded.raise(e);\n  }\n  async unload() {\n    super.unload(), await this._userUnloaded.raise();\n  }\n  /**\n   * Add callback: Raised when a user session has been established (or re-established).\n   */\n  addUserLoaded(e) {\n    return this._userLoaded.addHandler(e);\n  }\n  /**\n   * Remove callback: Raised when a user session has been established (or re-established).\n   */\n  removeUserLoaded(e) {\n    return this._userLoaded.removeHandler(e);\n  }\n  /**\n   * Add callback: Raised when a user session has been terminated.\n   */\n  addUserUnloaded(e) {\n    return this._userUnloaded.addHandler(e);\n  }\n  /**\n   * Remove callback: Raised when a user session has been terminated.\n   */\n  removeUserUnloaded(e) {\n    return this._userUnloaded.removeHandler(e);\n  }\n  /**\n   * Add callback: Raised when the automatic silent renew has failed.\n   */\n  addSilentRenewError(e) {\n    return this._silentRenewError.addHandler(e);\n  }\n  /**\n   * Remove callback: Raised when the automatic silent renew has failed.\n   */\n  removeSilentRenewError(e) {\n    return this._silentRenewError.removeHandler(e);\n  }\n  /**\n   * @internal\n   */\n  async _raiseSilentRenewError(e) {\n    await this._silentRenewError.raise(e);\n  }\n  /**\n   * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedIn(e) {\n    return this._userSignedIn.addHandler(e);\n  }\n  /**\n   * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n   */\n  removeUserSignedIn(e) {\n    this._userSignedIn.removeHandler(e);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSignedIn() {\n    await this._userSignedIn.raise();\n  }\n  /**\n   * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedOut(e) {\n    return this._userSignedOut.addHandler(e);\n  }\n  /**\n   * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   */\n  removeUserSignedOut(e) {\n    this._userSignedOut.removeHandler(e);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSignedOut() {\n    await this._userSignedOut.raise();\n  }\n  /**\n   * Add callback: Raised when the user session changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSessionChanged(e) {\n    return this._userSessionChanged.addHandler(e);\n  }\n  /**\n   * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n   */\n  removeUserSessionChanged(e) {\n    this._userSessionChanged.removeHandler(e);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSessionChanged() {\n    await this._userSessionChanged.raise();\n  }\n}, dt = class {\n  constructor(e) {\n    this._userManager = e, this._logger = new h(\"SilentRenewService\"), this._isStarted = !1, this._retryTimer = new R(\"Retry Silent Renew\"), this._tokenExpiring = async () => {\n      const t = this._logger.create(\"_tokenExpiring\");\n      try {\n        await this._userManager.signinSilent(), t.debug(\"silent token renewal successful\");\n      } catch (s) {\n        if (s instanceof ee) {\n          t.warn(\"ErrorTimeout from signinSilent:\", s, \"retry in 5s\"), this._retryTimer.init(5);\n          return;\n        }\n        t.error(\"Error from signinSilent:\", s), await this._userManager.events._raiseSilentRenewError(s);\n      }\n    };\n  }\n  async start() {\n    const e = this._logger.create(\"start\");\n    if (!this._isStarted) {\n      this._isStarted = !0, this._userManager.events.addAccessTokenExpiring(this._tokenExpiring), this._retryTimer.addHandler(this._tokenExpiring);\n      try {\n        await this._userManager.getUser();\n      } catch (t) {\n        e.error(\"getUser error\", t);\n      }\n    }\n  }\n  stop() {\n    this._isStarted && (this._retryTimer.cancel(), this._retryTimer.removeHandler(this._tokenExpiring), this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring), this._isStarted = !1);\n  }\n}, gt = class {\n  constructor(e) {\n    this.refresh_token = e.refresh_token, this.id_token = e.id_token, this.session_state = e.session_state, this.scope = e.scope, this.profile = e.profile, this.data = e.state;\n  }\n}, ht = class {\n  constructor(e, t, s, i) {\n    this._logger = new h(\"UserManager\"), this.settings = new it(e), this._client = new Ze(e), this._redirectNavigator = t ?? new ct(this.settings), this._popupNavigator = s ?? new at(this.settings), this._iframeNavigator = i ?? new rt(this.settings), this._events = new lt(this.settings), this._silentRenewService = new dt(this), this.settings.automaticSilentRenew && this.startSilentRenew(), this._sessionMonitor = null, this.settings.monitorSession && (this._sessionMonitor = new et(this));\n  }\n  /**\n   * Get object used to register for events raised by the `UserManager`.\n   */\n  get events() {\n    return this._events;\n  }\n  /**\n   * Get object used to access the metadata configuration of the identity provider.\n   */\n  get metadataService() {\n    return this._client.metadataService;\n  }\n  /**\n   * Load the `User` object for the currently authenticated user.\n   *\n   * @returns A promise\n   */\n  async getUser() {\n    const e = this._logger.create(\"getUser\"), t = await this._loadUser();\n    return t ? (e.info(\"user loaded\"), await this._events.load(t, !1), t) : (e.info(\"user not found in storage\"), null);\n  }\n  /**\n   * Remove from any storage the currently authenticated user.\n   *\n   * @returns A promise\n   */\n  async removeUser() {\n    const e = this._logger.create(\"removeUser\");\n    await this.storeUser(null), e.info(\"user removed from storage\"), await this._events.unload();\n  }\n  /**\n   * Trigger a redirect of the current window to the authorization endpoint.\n   *\n   * @returns A promise\n   *\n   * @throws `Error` In cases of wrong authentication.\n   */\n  async signinRedirect(e = {}) {\n    var t;\n    this._logger.create(\"signinRedirect\");\n    const {\n      redirectMethod: s,\n      ...i\n    } = e;\n    let r;\n    (t = this.settings.dpop) != null && t.bind_authorization_code && (r = await this.generateDPoPJkt(this.settings.dpop));\n    const o = await this._redirectNavigator.prepare({ redirectMethod: s });\n    await this._signinStart({\n      request_type: \"si:r\",\n      dpopJkt: r,\n      ...i\n    }, o);\n  }\n  /**\n   * Process the response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise containing the authenticated `User`.\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinRedirectCallback(e = window.location.href) {\n    const t = this._logger.create(\"signinRedirectCallback\"), s = await this._signinEnd(e);\n    return s.profile && s.profile.sub ? t.info(\"success, signed in subject\", s.profile.sub) : t.info(\"no subject\"), s;\n  }\n  /**\n   * Trigger the signin with user/password.\n   *\n   * @returns A promise containing the authenticated `User`.\n   * @throws {@link ErrorResponse} In cases of wrong authentication.\n   */\n  async signinResourceOwnerCredentials({\n    username: e,\n    password: t,\n    skipUserInfo: s = !1\n  }) {\n    const i = this._logger.create(\"signinResourceOwnerCredential\"), r = await this._client.processResourceOwnerPasswordCredentials({\n      username: e,\n      password: t,\n      skipUserInfo: s,\n      extraTokenParams: this.settings.extraTokenParams\n    });\n    i.debug(\"got signin response\");\n    const o = await this._buildUser(r);\n    return o.profile && o.profile.sub ? i.info(\"success, signed in subject\", o.profile.sub) : i.info(\"no subject\"), o;\n  }\n  /**\n   * Trigger a request (via a popup window) to the authorization endpoint.\n   *\n   * @returns A promise containing the authenticated `User`.\n   * @throws `Error` In cases of wrong authentication.\n   */\n  async signinPopup(e = {}) {\n    var t;\n    const s = this._logger.create(\"signinPopup\");\n    let i;\n    (t = this.settings.dpop) != null && t.bind_authorization_code && (i = await this.generateDPoPJkt(this.settings.dpop));\n    const {\n      popupWindowFeatures: r,\n      popupWindowTarget: o,\n      popupSignal: n,\n      ...a\n    } = e, c = this.settings.popup_redirect_uri;\n    c || s.throw(new Error(\"No popup_redirect_uri configured\"));\n    const l = await this._popupNavigator.prepare({ popupWindowFeatures: r, popupWindowTarget: o, popupSignal: n }), d = await this._signin({\n      request_type: \"si:p\",\n      redirect_uri: c,\n      display: \"popup\",\n      dpopJkt: i,\n      ...a\n    }, l);\n    return d && (d.profile && d.profile.sub ? s.info(\"success, signed in subject\", d.profile.sub) : s.info(\"no subject\")), d;\n  }\n  /**\n   * Notify the opening window of response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinPopupCallback(e = window.location.href, t = !1) {\n    const s = this._logger.create(\"signinPopupCallback\");\n    await this._popupNavigator.callback(e, { keepOpen: t }), s.info(\"success\");\n  }\n  /**\n   * Trigger a silent request (via refresh token or an iframe) to the authorization endpoint.\n   *\n   * @returns A promise that contains the authenticated `User`.\n   */\n  async signinSilent(e = {}) {\n    var t, s;\n    const i = this._logger.create(\"signinSilent\"), {\n      silentRequestTimeoutInSeconds: r,\n      ...o\n    } = e;\n    let n = await this._loadUser();\n    if (n != null && n.refresh_token) {\n      i.debug(\"using refresh token\");\n      const g = new gt(n);\n      return await this._useRefreshToken({\n        state: g,\n        redirect_uri: o.redirect_uri,\n        resource: o.resource,\n        extraTokenParams: o.extraTokenParams,\n        timeoutInSeconds: r\n      });\n    }\n    let a;\n    (t = this.settings.dpop) != null && t.bind_authorization_code && (a = await this.generateDPoPJkt(this.settings.dpop));\n    const c = this.settings.silent_redirect_uri;\n    c || i.throw(new Error(\"No silent_redirect_uri configured\"));\n    let l;\n    n && this.settings.validateSubOnSilentRenew && (i.debug(\"subject prior to silent renew:\", n.profile.sub), l = n.profile.sub);\n    const d = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds: r });\n    return n = await this._signin({\n      request_type: \"si:s\",\n      redirect_uri: c,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? n == null ? void 0 : n.id_token : void 0,\n      dpopJkt: a,\n      ...o\n    }, d, l), n && ((s = n.profile) != null && s.sub ? i.info(\"success, signed in subject\", n.profile.sub) : i.info(\"no subject\")), n;\n  }\n  async _useRefreshToken(e) {\n    const t = await this._client.useRefreshToken({\n      timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds,\n      ...e\n    }), s = new z({ ...e.state, ...t });\n    return await this.storeUser(s), await this._events.load(s), s;\n  }\n  /**\n   *\n   * Notify the parent window of response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinSilentCallback(e = window.location.href) {\n    const t = this._logger.create(\"signinSilentCallback\");\n    await this._iframeNavigator.callback(e), t.info(\"success\");\n  }\n  /**\n   * Process any response (callback) from the authorization endpoint, by dispatching the request_type\n   * and executing one of the following functions:\n   * - {@link UserManager.signinRedirectCallback}\n   * - {@link UserManager.signinPopupCallback}\n   * - {@link UserManager.signinSilentCallback}\n   *\n   * @throws `Error` If request_type is unknown or signin cannot be processed.\n   */\n  async signinCallback(e = window.location.href) {\n    const { state: t } = await this._client.readSigninResponseState(e);\n    switch (t.request_type) {\n      case \"si:r\":\n        return await this.signinRedirectCallback(e);\n      case \"si:p\":\n        await this.signinPopupCallback(e);\n        break;\n      case \"si:s\":\n        await this.signinSilentCallback(e);\n        break;\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n  }\n  /**\n   * Process any response (callback) from the end session endpoint, by dispatching the request_type\n   * and executing one of the following functions:\n   * - {@link UserManager.signoutRedirectCallback}\n   * - {@link UserManager.signoutPopupCallback}\n   * - {@link UserManager.signoutSilentCallback}\n   *\n   * @throws `Error` If request_type is unknown or signout cannot be processed.\n   */\n  async signoutCallback(e = window.location.href, t = !1) {\n    const { state: s } = await this._client.readSignoutResponseState(e);\n    if (s)\n      switch (s.request_type) {\n        case \"so:r\":\n          return await this.signoutRedirectCallback(e);\n        case \"so:p\":\n          await this.signoutPopupCallback(e, t);\n          break;\n        case \"so:s\":\n          await this.signoutSilentCallback(e);\n          break;\n        default:\n          throw new Error(\"invalid response_type in state\");\n      }\n  }\n  /**\n   * Query OP for user's current signin status.\n   *\n   * @returns A promise object with session_state and subject identifier.\n   */\n  async querySessionStatus(e = {}) {\n    const t = this._logger.create(\"querySessionStatus\"), {\n      silentRequestTimeoutInSeconds: s,\n      ...i\n    } = e, r = this.settings.silent_redirect_uri;\n    r || t.throw(new Error(\"No silent_redirect_uri configured\"));\n    const o = await this._loadUser(), n = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds: s }), a = await this._signinStart({\n      request_type: \"si:s\",\n      // this acts like a signin silent\n      redirect_uri: r,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? o == null ? void 0 : o.id_token : void 0,\n      response_type: this.settings.query_status_response_type,\n      scope: \"openid\",\n      skipUserInfo: !0,\n      ...i\n    }, n);\n    try {\n      const c = {}, l = await this._client.processSigninResponse(a.url, c);\n      return t.debug(\"got signin response\"), l.session_state && l.profile.sub ? (t.info(\"success for subject\", l.profile.sub), {\n        session_state: l.session_state,\n        sub: l.profile.sub\n      }) : (t.info(\"success, user not authenticated\"), null);\n    } catch (c) {\n      if (this.settings.monitorAnonymousSession && c instanceof D)\n        switch (c.error) {\n          case \"login_required\":\n          case \"consent_required\":\n          case \"interaction_required\":\n          case \"account_selection_required\":\n            return t.info(\"success for anonymous user\"), {\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              session_state: c.session_state\n            };\n        }\n      throw c;\n    }\n  }\n  async _signin(e, t, s) {\n    const i = await this._signinStart(e, t);\n    return await this._signinEnd(i.url, s);\n  }\n  async _signinStart(e, t) {\n    const s = this._logger.create(\"_signinStart\");\n    try {\n      const i = await this._client.createSigninRequest(e);\n      return s.debug(\"got signin request\"), await t.navigate({\n        url: i.url,\n        state: i.state.id,\n        response_mode: i.state.response_mode,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (i) {\n      throw s.debug(\"error after preparing navigator, closing navigator window\"), t.close(), i;\n    }\n  }\n  async _signinEnd(e, t) {\n    const s = this._logger.create(\"_signinEnd\"), i = {}, r = await this._client.processSigninResponse(e, i);\n    return s.debug(\"got signin response\"), await this._buildUser(r, t);\n  }\n  async _buildUser(e, t) {\n    const s = this._logger.create(\"_buildUser\"), i = new z(e);\n    if (t) {\n      if (t !== i.profile.sub)\n        throw s.debug(\"current user does not match user returned from signin. sub from signin:\", i.profile.sub), new D({ ...e, error: \"login_required\" });\n      s.debug(\"current user matches user returned from signin\");\n    }\n    return await this.storeUser(i), s.debug(\"user stored\"), await this._events.load(i), i;\n  }\n  /**\n   * Trigger a redirect of the current window to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutRedirect(e = {}) {\n    const t = this._logger.create(\"signoutRedirect\"), {\n      redirectMethod: s,\n      ...i\n    } = e, r = await this._redirectNavigator.prepare({ redirectMethod: s });\n    await this._signoutStart({\n      request_type: \"so:r\",\n      post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n      ...i\n    }, r), t.info(\"success\");\n  }\n  /**\n   * Process response (callback) from the end session endpoint.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise containing signout response\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutRedirectCallback(e = window.location.href) {\n    const t = this._logger.create(\"signoutRedirectCallback\"), s = await this._signoutEnd(e);\n    return t.info(\"success\"), s;\n  }\n  /**\n   * Trigger a redirect of a popup window to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutPopup(e = {}) {\n    const t = this._logger.create(\"signoutPopup\"), {\n      popupWindowFeatures: s,\n      popupWindowTarget: i,\n      popupSignal: r,\n      ...o\n    } = e, n = this.settings.popup_post_logout_redirect_uri, a = await this._popupNavigator.prepare({ popupWindowFeatures: s, popupWindowTarget: i, popupSignal: r });\n    await this._signout({\n      request_type: \"so:p\",\n      post_logout_redirect_uri: n,\n      // we're putting a dummy entry in here because we\n      // need a unique id from the state for notification\n      // to the parent window, which is necessary if we\n      // plan to return back to the client after signout\n      // and so we can close the popup after signout\n      state: n == null ? void 0 : {},\n      ...o\n    }, a), t.info(\"success\");\n  }\n  /**\n   * Process response (callback) from the end session endpoint from a popup window.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutPopupCallback(e = window.location.href, t = !1) {\n    const s = this._logger.create(\"signoutPopupCallback\");\n    await this._popupNavigator.callback(e, { keepOpen: t }), s.info(\"success\");\n  }\n  async _signout(e, t) {\n    const s = await this._signoutStart(e, t);\n    return await this._signoutEnd(s.url);\n  }\n  async _signoutStart(e = {}, t) {\n    var s;\n    const i = this._logger.create(\"_signoutStart\");\n    try {\n      const r = await this._loadUser();\n      i.debug(\"loaded current user from storage\"), this.settings.revokeTokensOnSignout && await this._revokeInternal(r);\n      const o = e.id_token_hint || r && r.id_token;\n      o && (i.debug(\"setting id_token_hint in signout request\"), e.id_token_hint = o), await this.removeUser(), i.debug(\"user removed, creating signout request\");\n      const n = await this._client.createSignoutRequest(e);\n      return i.debug(\"got signout request\"), await t.navigate({\n        url: n.url,\n        state: (s = n.state) == null ? void 0 : s.id,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (r) {\n      throw i.debug(\"error after preparing navigator, closing navigator window\"), t.close(), r;\n    }\n  }\n  async _signoutEnd(e) {\n    const t = this._logger.create(\"_signoutEnd\"), s = await this._client.processSignoutResponse(e);\n    return t.debug(\"got signout response\"), s;\n  }\n  /**\n   * Trigger a silent request (via an iframe) to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutSilent(e = {}) {\n    var t;\n    const s = this._logger.create(\"signoutSilent\"), {\n      silentRequestTimeoutInSeconds: i,\n      ...r\n    } = e, o = this.settings.includeIdTokenInSilentSignout ? (t = await this._loadUser()) == null ? void 0 : t.id_token : void 0, n = this.settings.popup_post_logout_redirect_uri, a = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds: i });\n    await this._signout({\n      request_type: \"so:s\",\n      post_logout_redirect_uri: n,\n      id_token_hint: o,\n      ...r\n    }, a), s.info(\"success\");\n  }\n  /**\n   * Notify the parent window of response (callback) from the end session endpoint.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutSilentCallback(e = window.location.href) {\n    const t = this._logger.create(\"signoutSilentCallback\");\n    await this._iframeNavigator.callback(e), t.info(\"success\");\n  }\n  async revokeTokens(e) {\n    const t = await this._loadUser();\n    await this._revokeInternal(t, e);\n  }\n  async _revokeInternal(e, t = this.settings.revokeTokenTypes) {\n    const s = this._logger.create(\"_revokeInternal\");\n    if (!e) return;\n    const i = t.filter((r) => typeof e[r] == \"string\");\n    if (!i.length) {\n      s.debug(\"no need to revoke due to no token(s)\");\n      return;\n    }\n    for (const r of i)\n      await this._client.revokeToken(\n        e[r],\n        // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        r\n      ), s.info(`${r} revoked successfully`), r !== \"access_token\" && (e[r] = null);\n    await this.storeUser(e), s.debug(\"user stored\"), await this._events.load(e);\n  }\n  /**\n   * Enables silent renew for the `UserManager`.\n   */\n  startSilentRenew() {\n    this._logger.create(\"startSilentRenew\"), this._silentRenewService.start();\n  }\n  /**\n   * Disables silent renew for the `UserManager`.\n   */\n  stopSilentRenew() {\n    this._silentRenewService.stop();\n  }\n  get _userStoreKey() {\n    return `user:${this.settings.authority}:${this.settings.client_id}`;\n  }\n  async _loadUser() {\n    const e = this._logger.create(\"_loadUser\"), t = await this.settings.userStore.get(this._userStoreKey);\n    return t ? (e.debug(\"user storageString loaded\"), z.fromStorageString(t)) : (e.debug(\"no user storageString\"), null);\n  }\n  async storeUser(e) {\n    const t = this._logger.create(\"storeUser\");\n    if (e) {\n      t.debug(\"storing user\");\n      const s = e.toStorageString();\n      await this.settings.userStore.set(this._userStoreKey, s);\n    } else\n      this._logger.debug(\"removing user\"), await this.settings.userStore.remove(this._userStoreKey), this.settings.dpop && await this.settings.dpop.store.remove(this.settings.client_id);\n  }\n  /**\n   * Removes stale state entries in storage for incomplete authorize requests.\n   */\n  async clearStaleState() {\n    await this._client.clearStaleState();\n  }\n  /**\n   * Dynamically generates a DPoP proof for a given user, URL and optional Http method.\n   * This method is useful when you need to make a request to a resource server\n   * with fetch or similar, and you need to include a DPoP proof in a DPoP header.\n   * @param url - The URL to generate the DPoP proof for\n   * @param user - The user to generate the DPoP proof for\n   * @param httpMethod - Optional, defaults to \"GET\"\n   * @param nonce - Optional nonce provided by the resource server\n   *\n   * @returns A promise containing the DPoP proof or undefined if DPoP is not enabled/no user is found.\n   */\n  async dpopProof(e, t, s, i) {\n    var r, o;\n    const n = await ((o = (r = this.settings.dpop) == null ? void 0 : r.store) == null ? void 0 : o.get(this.settings.client_id));\n    if (n)\n      return await f.generateDPoPProof({\n        url: e,\n        accessToken: t == null ? void 0 : t.access_token,\n        httpMethod: s,\n        keyPair: n.keys,\n        nonce: i\n      });\n  }\n  async generateDPoPJkt(e) {\n    let t = await e.store.get(this.settings.client_id);\n    if (!t) {\n      const s = await f.generateDPoPKeys();\n      t = new fe(s), await e.store.set(this.settings.client_id, t);\n    }\n    return await f.generateDPoPJkt(t.keys);\n  }\n};\nconst ut = async () => {\n  const e = localStorage.getItem(\"config.oidc_endpoints\");\n  if (e) {\n    const { serverUrl: i } = M();\n    if (JSON.parse(e).issuer.includes(i || \"\")) return JSON.parse(e);\n  }\n  const { serverUrl: t } = M(), s = `https://${t}/.well-known/openid-configuration`;\n  try {\n    const r = await (await fetch(s)).json();\n    return localStorage.setItem(\"config.oidc_endpoints\", JSON.stringify(r)), r;\n  } catch (i) {\n    throw console.error(\"Failed to fetch OIDC configuration:\", i), i instanceof Error ? new S(w.FailedToFetchOIDCConfiguration, i.message) : new S(w.FailedToFetchOIDCConfiguration, \"unable to fetch OIDC configuration\");\n  }\n}, St = async (e) => {\n  const { redirectCallbackUri: t, postLoginRedirectUri: s, postLogoutRedirectUri: i, state: r, login_code: o } = e;\n  localStorage.setItem(\"config.post_login_redirect_uri\", s || window.location.origin), localStorage.setItem(\"config.post_logout_redirect_uri\", i || window.location.origin);\n  try {\n    const n = await j({\n      redirectCallbackUri: t,\n      postLogoutRedirectUri: i\n    });\n    return await n.signinRedirect({\n      extraQueryParams: {\n        brand: \"deriv\",\n        ...o ? { login_code: o } : {}\n      },\n      state: r\n    }), { userManager: n };\n  } catch (n) {\n    throw console.error(\"Authentication failed:\", n), n instanceof Error ? new S(w.AuthenticationRequestFailed, n.message) : new S(w.AuthenticationRequestFailed, \"unable to request OIDC authentication\");\n  }\n}, vt = async (e) => {\n  const { redirectCallbackUri: t, redirectSilentCallbackUri: s, state: i, login_code: r } = e;\n  try {\n    const o = await j({\n      redirectCallbackUri: t,\n      redirectSilentCallbackUri: s\n    });\n    return await o.signinSilent({\n      extraQueryParams: {\n        brand: \"deriv\",\n        ...r ? { login_code: r } : {}\n      },\n      state: i,\n      silentRequestTimeoutInSeconds: 6e4\n    }), { userManager: o };\n  } catch (o) {\n    console.error(\"Authentication failed:\", o);\n  }\n}, yt = async (e) => {\n  const { redirectCallbackUri: t, postLogoutRedirectUri: s } = e;\n  try {\n    const r = await (await j({\n      redirectCallbackUri: t,\n      postLogoutRedirectUri: s\n    })).signinCallback();\n    return {\n      accessToken: r == null ? void 0 : r.access_token,\n      user: r\n    };\n  } catch (i) {\n    throw console.error(\"unable to request access tokens: \", i), i instanceof Error ? new S(w.AccessTokenRequestFailed, i.message) : new S(w.AccessTokenRequestFailed, \"unable to request access tokens\");\n  }\n}, kt = async (e) => {\n  const { serverUrl: t } = M();\n  try {\n    return await (await fetch(`https://${t}/oauth2/legacy/tokens`, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${e}`\n      }\n    })).json();\n  } catch (s) {\n    throw console.error(\"unable to request legacy tokens: \", s), s instanceof Error ? new S(w.LegacyTokenRequestFailed, s.message) : new S(w.LegacyTokenRequestFailed, \"unable to request legacy tokens\");\n  }\n}, bt = async (e) => {\n  const { serverUrl: t } = M();\n  try {\n    await fetch(`https://${t}/oauth2/legacy/tokens/revoke`, {\n      method: \"POST\",\n      body: JSON.stringify(e)\n    });\n  } catch (s) {\n    console.error(\"unable to request legacy tokens: \", w.RevokeTokenRequestFailed, s);\n  }\n}, j = async (e) => {\n  const { redirectCallbackUri: t, redirectSilentCallbackUri: s, postLogoutRedirectUri: i } = e, { appId: r } = M(), { postLogoutRedirectUri: o } = xe(), n = t || `${window.location.origin}/callback`, a = i || o || window.location.origin;\n  try {\n    const c = await ut();\n    return new ht({\n      authority: c.issuer,\n      client_id: r,\n      redirect_uri: n,\n      silent_redirect_uri: s,\n      response_type: \"code\",\n      scope: \"openid\",\n      stateStore: new se({ store: window.localStorage }),\n      post_logout_redirect_uri: a,\n      // this is enabled by default, it runs a silent renew service in the background which triggers the prompt=none auth calls\n      // Source: https://github.com/authts/oidc-client-ts/blob/9ccae8f87b3e9e2df349aaf6f007964ced287b02/src/UserManagerSettings.ts#L140\n      // Notable issue: https://github.com/authts/oidc-client-ts/issues/1174\n      automaticSilentRenew: !1\n    });\n  } catch (c) {\n    throw console.error(\"unable to create user manager for OIDC: \", c), c instanceof Error ? new S(w.UserManagerCreationFailed, c.message) : new S(w.UserManagerCreationFailed, \"unable to create user manager for OIDC\");\n  }\n}, Et = async (e) => {\n  const t = localStorage.getItem(\"config.oidc_endpoints\") || \"{}\";\n  let s = Pe() || JSON.parse(t).end_session_endpoint;\n  const r = await (await j({\n    redirectCallbackUri: e.redirectCallbackUri\n  })).getUser();\n  r != null && r.id_token && (s += `?id_token_hint=${r.id_token}`);\n  const o = () => {\n    const c = document.getElementById(\"logout-iframe\");\n    c && c.remove(), _t({\n      redirectCallbackUri: e.redirectCallbackUri,\n      postLogoutRedirectUri: e.postLogoutRedirectUri\n    });\n  }, n = (c) => {\n    if (c.data === \"logout_complete\") {\n      const l = [\"deriv.com\", \"deriv.dev\", \"binary.sx\", \"pages.dev\", \"localhost\", \"deriv.be\", \"deriv.me\"], d = window.location.hostname.split(\".\").slice(-2).join(\".\");\n      l.includes(d) && le.set(\"logged_state\", \"false\", {\n        expires: 30,\n        path: \"/\",\n        domain: d,\n        secure: !0\n      }), e.WSLogoutAndRedirect(), o(), window.removeEventListener(\"message\", n);\n    }\n  };\n  window.addEventListener(\"message\", n);\n  let a = document.getElementById(\"logout-iframe\");\n  a || (a = document.createElement(\"iframe\"), a.id = \"logout-iframe\", a.style.display = \"none\", document.body.appendChild(a)), a.src = s, a.onerror = (c) => {\n    console.error(\"There has been a problem with the logout: \", c), o();\n  };\n}, Tt = async (e) => {\n  try {\n    const { redirectCallbackUri: t, postLogoutRedirectUri: s } = e, { appId: i } = M(), n = `oidc.user:${JSON.parse(localStorage.getItem(\"config.oidc_endpoints\") || \"{}\").issuer}:${i}`, a = JSON.parse(window.sessionStorage.getItem(n) || \"{}\");\n    if (!a.id_token)\n      throw new Error(\"ID token is missing in session storage.\");\n    await (await j({\n      redirectCallbackUri: t,\n      postLogoutRedirectUri: s\n    })).signoutRedirect({\n      id_token_hint: a.id_token,\n      post_logout_redirect_uri: s\n    });\n  } catch (t) {\n    throw console.error(\"Error during logout:\", t), new Error(`Logout failed. ${t}`);\n  }\n}, _t = async (e) => {\n  try {\n    const t = await j(e);\n    await t.removeUser(), await t.clearStaleState();\n  } catch (t) {\n    throw t instanceof Error ? new S(w.FailedToRemoveSession, t.message) : new S(w.FailedToRemoveSession, \"unable to remove OIDC session\");\n  }\n}, It = (e) => {\n  const { appId: t } = M(), r = `oidc.user:${JSON.parse(localStorage.getItem(\"config.oidc_endpoints\") || \"{}\").issuer}:${t}`;\n  if (!window.sessionStorage.getItem(r)) {\n    const o = [\"deriv.com\", \"deriv.dev\", \"binary.sx\", \"pages.dev\", \"localhost\", \"deriv.be\", \"deriv.me\"], n = window.location.hostname.split(\".\").slice(-2).join(\".\");\n    o.includes(n) && le.set(\"logged_state\", \"false\", {\n      expires: 30,\n      path: \"/\",\n      domain: n,\n      secure: !0\n    }), e();\n  }\n};\nexport {\n  Et as OAuth2Logout,\n  _t as clearOIDCStorage,\n  j as createUserManager,\n  ut as fetchOidcConfiguration,\n  It as handlePostLogout,\n  Tt as oidcLogout,\n  kt as requestLegacyToken,\n  St as requestOidcAuthentication,\n  vt as requestOidcSilentAuthentication,\n  yt as requestOidcToken,\n  bt as revokeLegacyTokens\n};\n","import we from \"react\";\nvar Z = { exports: {} }, D = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Oe;\nfunction lr() {\n  if (Oe) return D;\n  Oe = 1;\n  var M = we, C = Symbol.for(\"react.element\"), U = Symbol.for(\"react.fragment\"), m = Object.prototype.hasOwnProperty, A = M.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, I = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function P(h, c, T) {\n    var p, b = {}, _ = null, W = null;\n    T !== void 0 && (_ = \"\" + T), c.key !== void 0 && (_ = \"\" + c.key), c.ref !== void 0 && (W = c.ref);\n    for (p in c) m.call(c, p) && !I.hasOwnProperty(p) && (b[p] = c[p]);\n    if (h && h.defaultProps) for (p in c = h.defaultProps, c) b[p] === void 0 && (b[p] = c[p]);\n    return { $$typeof: C, type: h, key: _, ref: W, props: b, _owner: A.current };\n  }\n  return D.Fragment = U, D.jsx = P, D.jsxs = P, D;\n}\nvar F = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Se;\nfunction cr() {\n  return Se || (Se = 1, process.env.NODE_ENV !== \"production\" && function() {\n    var M = we, C = Symbol.for(\"react.element\"), U = Symbol.for(\"react.portal\"), m = Symbol.for(\"react.fragment\"), A = Symbol.for(\"react.strict_mode\"), I = Symbol.for(\"react.profiler\"), P = Symbol.for(\"react.provider\"), h = Symbol.for(\"react.context\"), c = Symbol.for(\"react.forward_ref\"), T = Symbol.for(\"react.suspense\"), p = Symbol.for(\"react.suspense_list\"), b = Symbol.for(\"react.memo\"), _ = Symbol.for(\"react.lazy\"), W = Symbol.for(\"react.offscreen\"), Q = Symbol.iterator, Ce = \"@@iterator\";\n    function Pe(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var r = Q && e[Q] || e[Ce];\n      return typeof r == \"function\" ? r : null;\n    }\n    var O = M.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function l(e) {\n      {\n        for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)\n          t[n - 1] = arguments[n];\n        je(\"error\", e, t);\n      }\n    }\n    function je(e, r, t) {\n      {\n        var n = O.ReactDebugCurrentFrame, i = n.getStackAddendum();\n        i !== \"\" && (r += \"%s\", t = t.concat([i]));\n        var u = t.map(function(o) {\n          return String(o);\n        });\n        u.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, u);\n      }\n    }\n    var xe = !1, ke = !1, De = !1, Fe = !1, Ae = !1, ee;\n    ee = Symbol.for(\"react.module.reference\");\n    function Ie(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === m || e === I || Ae || e === A || e === T || e === p || Fe || e === W || xe || ke || De || typeof e == \"object\" && e !== null && (e.$$typeof === _ || e.$$typeof === b || e.$$typeof === P || e.$$typeof === h || e.$$typeof === c || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      e.$$typeof === ee || e.getModuleId !== void 0));\n    }\n    function We(e, r, t) {\n      var n = e.displayName;\n      if (n)\n        return n;\n      var i = r.displayName || r.name || \"\";\n      return i !== \"\" ? t + \"(\" + i + \")\" : t;\n    }\n    function re(e) {\n      return e.displayName || \"Context\";\n    }\n    function y(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && l(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case m:\n          return \"Fragment\";\n        case U:\n          return \"Portal\";\n        case I:\n          return \"Profiler\";\n        case A:\n          return \"StrictMode\";\n        case T:\n          return \"Suspense\";\n        case p:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case h:\n            var r = e;\n            return re(r) + \".Consumer\";\n          case P:\n            var t = e;\n            return re(t._context) + \".Provider\";\n          case c:\n            return We(e, e.render, \"ForwardRef\");\n          case b:\n            var n = e.displayName || null;\n            return n !== null ? n : y(e.type) || \"Memo\";\n          case _: {\n            var i = e, u = i._payload, o = i._init;\n            try {\n              return y(o(u));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var E = Object.assign, j = 0, te, ne, ae, oe, ie, ue, se;\n    function fe() {\n    }\n    fe.__reactDisabledLog = !0;\n    function Ye() {\n      {\n        if (j === 0) {\n          te = console.log, ne = console.info, ae = console.warn, oe = console.error, ie = console.group, ue = console.groupCollapsed, se = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: fe,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        j++;\n      }\n    }\n    function $e() {\n      {\n        if (j--, j === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: E({}, e, {\n              value: te\n            }),\n            info: E({}, e, {\n              value: ne\n            }),\n            warn: E({}, e, {\n              value: ae\n            }),\n            error: E({}, e, {\n              value: oe\n            }),\n            group: E({}, e, {\n              value: ie\n            }),\n            groupCollapsed: E({}, e, {\n              value: ue\n            }),\n            groupEnd: E({}, e, {\n              value: se\n            })\n          });\n        }\n        j < 0 && l(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var N = O.ReactCurrentDispatcher, B;\n    function Y(e, r, t) {\n      {\n        if (B === void 0)\n          try {\n            throw Error();\n          } catch (i) {\n            var n = i.stack.trim().match(/\\n( *(at )?)/);\n            B = n && n[1] || \"\";\n          }\n        return `\n` + B + e;\n      }\n    }\n    var J = !1, $;\n    {\n      var Le = typeof WeakMap == \"function\" ? WeakMap : Map;\n      $ = new Le();\n    }\n    function le(e, r) {\n      if (!e || J)\n        return \"\";\n      {\n        var t = $.get(e);\n        if (t !== void 0)\n          return t;\n      }\n      var n;\n      J = !0;\n      var i = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var u;\n      u = N.current, N.current = null, Ye();\n      try {\n        if (r) {\n          var o = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(o.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(o, []);\n            } catch (d) {\n              n = d;\n            }\n            Reflect.construct(e, [], o);\n          } else {\n            try {\n              o.call();\n            } catch (d) {\n              n = d;\n            }\n            e.call(o.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (d) {\n            n = d;\n          }\n          e();\n        }\n      } catch (d) {\n        if (d && n && typeof d.stack == \"string\") {\n          for (var a = d.stack.split(`\n`), v = n.stack.split(`\n`), s = a.length - 1, f = v.length - 1; s >= 1 && f >= 0 && a[s] !== v[f]; )\n            f--;\n          for (; s >= 1 && f >= 0; s--, f--)\n            if (a[s] !== v[f]) {\n              if (s !== 1 || f !== 1)\n                do\n                  if (s--, f--, f < 0 || a[s] !== v[f]) {\n                    var g = `\n` + a[s].replace(\" at new \", \" at \");\n                    return e.displayName && g.includes(\"<anonymous>\") && (g = g.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && $.set(e, g), g;\n                  }\n                while (s >= 1 && f >= 0);\n              break;\n            }\n        }\n      } finally {\n        J = !1, N.current = u, $e(), Error.prepareStackTrace = i;\n      }\n      var w = e ? e.displayName || e.name : \"\", R = w ? Y(w) : \"\";\n      return typeof e == \"function\" && $.set(e, R), R;\n    }\n    function Ve(e, r, t) {\n      return le(e, !1);\n    }\n    function Me(e) {\n      var r = e.prototype;\n      return !!(r && r.isReactComponent);\n    }\n    function L(e, r, t) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return le(e, Me(e));\n      if (typeof e == \"string\")\n        return Y(e);\n      switch (e) {\n        case T:\n          return Y(\"Suspense\");\n        case p:\n          return Y(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case c:\n            return Ve(e.render);\n          case b:\n            return L(e.type, r, t);\n          case _: {\n            var n = e, i = n._payload, u = n._init;\n            try {\n              return L(u(i), r, t);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var x = Object.prototype.hasOwnProperty, ce = {}, ve = O.ReactDebugCurrentFrame;\n    function V(e) {\n      if (e) {\n        var r = e._owner, t = L(e.type, e._source, r ? r.type : null);\n        ve.setExtraStackFrame(t);\n      } else\n        ve.setExtraStackFrame(null);\n    }\n    function Ue(e, r, t, n, i) {\n      {\n        var u = Function.call.bind(x);\n        for (var o in e)\n          if (u(e, o)) {\n            var a = void 0;\n            try {\n              if (typeof e[o] != \"function\") {\n                var v = Error((n || \"React class\") + \": \" + t + \" type `\" + o + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[o] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw v.name = \"Invariant Violation\", v;\n              }\n              a = e[o](r, o, n, t, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (s) {\n              a = s;\n            }\n            a && !(a instanceof Error) && (V(i), l(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", n || \"React class\", t, o, typeof a), V(null)), a instanceof Error && !(a.message in ce) && (ce[a.message] = !0, V(i), l(\"Failed %s type: %s\", t, a.message), V(null));\n          }\n      }\n    }\n    var Ne = Array.isArray;\n    function K(e) {\n      return Ne(e);\n    }\n    function Be(e) {\n      {\n        var r = typeof Symbol == \"function\" && Symbol.toStringTag, t = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return t;\n      }\n    }\n    function Je(e) {\n      try {\n        return de(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function de(e) {\n      return \"\" + e;\n    }\n    function pe(e) {\n      if (Je(e))\n        return l(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", Be(e)), de(e);\n    }\n    var k = O.ReactCurrentOwner, Ke = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, ge, ye, q;\n    q = {};\n    function qe(e) {\n      if (x.call(e, \"ref\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function Ge(e) {\n      if (x.call(e, \"key\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function ze(e, r) {\n      if (typeof e.ref == \"string\" && k.current && r && k.current.stateNode !== r) {\n        var t = y(k.current.type);\n        q[t] || (l('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', y(k.current.type), e.ref), q[t] = !0);\n      }\n    }\n    function Xe(e, r) {\n      {\n        var t = function() {\n          ge || (ge = !0, l(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    function He(e, r) {\n      {\n        var t = function() {\n          ye || (ye = !0, l(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    var Ze = function(e, r, t, n, i, u, o) {\n      var a = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: C,\n        // Built-in properties that belong on the element\n        type: e,\n        key: r,\n        ref: t,\n        props: o,\n        // Record the component responsible for creating this element.\n        _owner: u\n      };\n      return a._store = {}, Object.defineProperty(a._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(a, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: n\n      }), Object.defineProperty(a, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: i\n      }), Object.freeze && (Object.freeze(a.props), Object.freeze(a)), a;\n    };\n    function Qe(e, r, t, n, i) {\n      {\n        var u, o = {}, a = null, v = null;\n        t !== void 0 && (pe(t), a = \"\" + t), Ge(r) && (pe(r.key), a = \"\" + r.key), qe(r) && (v = r.ref, ze(r, i));\n        for (u in r)\n          x.call(r, u) && !Ke.hasOwnProperty(u) && (o[u] = r[u]);\n        if (e && e.defaultProps) {\n          var s = e.defaultProps;\n          for (u in s)\n            o[u] === void 0 && (o[u] = s[u]);\n        }\n        if (a || v) {\n          var f = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          a && Xe(o, f), v && He(o, f);\n        }\n        return Ze(e, a, v, i, n, k.current, o);\n      }\n    }\n    var G = O.ReactCurrentOwner, be = O.ReactDebugCurrentFrame;\n    function S(e) {\n      if (e) {\n        var r = e._owner, t = L(e.type, e._source, r ? r.type : null);\n        be.setExtraStackFrame(t);\n      } else\n        be.setExtraStackFrame(null);\n    }\n    var z;\n    z = !1;\n    function X(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === C;\n    }\n    function he() {\n      {\n        if (G.current) {\n          var e = y(G.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function er(e) {\n      return \"\";\n    }\n    var _e = {};\n    function rr(e) {\n      {\n        var r = he();\n        if (!r) {\n          var t = typeof e == \"string\" ? e : e.displayName || e.name;\n          t && (r = `\n\nCheck the top-level render call using <` + t + \">.\");\n        }\n        return r;\n      }\n    }\n    function Ee(e, r) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var t = rr(r);\n        if (_e[t])\n          return;\n        _e[t] = !0;\n        var n = \"\";\n        e && e._owner && e._owner !== G.current && (n = \" It was passed a child from \" + y(e._owner.type) + \".\"), S(e), l('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, n), S(null);\n      }\n    }\n    function Re(e, r) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (K(e))\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];\n            X(n) && Ee(n, r);\n          }\n        else if (X(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var i = Pe(e);\n          if (typeof i == \"function\" && i !== e.entries)\n            for (var u = i.call(e), o; !(o = u.next()).done; )\n              X(o.value) && Ee(o.value, r);\n        }\n      }\n    }\n    function tr(e) {\n      {\n        var r = e.type;\n        if (r == null || typeof r == \"string\")\n          return;\n        var t;\n        if (typeof r == \"function\")\n          t = r.propTypes;\n        else if (typeof r == \"object\" && (r.$$typeof === c || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        r.$$typeof === b))\n          t = r.propTypes;\n        else\n          return;\n        if (t) {\n          var n = y(r);\n          Ue(t, e.props, \"prop\", n, e);\n        } else if (r.PropTypes !== void 0 && !z) {\n          z = !0;\n          var i = y(r);\n          l(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", i || \"Unknown\");\n        }\n        typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && l(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function nr(e) {\n      {\n        for (var r = Object.keys(e.props), t = 0; t < r.length; t++) {\n          var n = r[t];\n          if (n !== \"children\" && n !== \"key\") {\n            S(e), l(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", n), S(null);\n            break;\n          }\n        }\n        e.ref !== null && (S(e), l(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), S(null));\n      }\n    }\n    var me = {};\n    function Te(e, r, t, n, i, u) {\n      {\n        var o = Ie(e);\n        if (!o) {\n          var a = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (a += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var v = er();\n          v ? a += v : a += he();\n          var s;\n          e === null ? s = \"null\" : K(e) ? s = \"array\" : e !== void 0 && e.$$typeof === C ? (s = \"<\" + (y(e.type) || \"Unknown\") + \" />\", a = \" Did you accidentally export a JSX literal instead of a component?\") : s = typeof e, l(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", s, a);\n        }\n        var f = Qe(e, r, t, i, u);\n        if (f == null)\n          return f;\n        if (o) {\n          var g = r.children;\n          if (g !== void 0)\n            if (n)\n              if (K(g)) {\n                for (var w = 0; w < g.length; w++)\n                  Re(g[w], e);\n                Object.freeze && Object.freeze(g);\n              } else\n                l(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Re(g, e);\n        }\n        if (x.call(r, \"key\")) {\n          var R = y(e), d = Object.keys(r).filter(function(fr) {\n            return fr !== \"key\";\n          }), H = d.length > 0 ? \"{key: someKey, \" + d.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n          if (!me[R + H]) {\n            var sr = d.length > 0 ? \"{\" + d.join(\": ..., \") + \": ...}\" : \"{}\";\n            l(`A props object containing a \"key\" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />`, H, R, sr, R), me[R + H] = !0;\n          }\n        }\n        return e === m ? nr(f) : tr(f), f;\n      }\n    }\n    function ar(e, r, t) {\n      return Te(e, r, t, !0);\n    }\n    function or(e, r, t) {\n      return Te(e, r, t, !1);\n    }\n    var ir = or, ur = ar;\n    F.Fragment = m, F.jsx = ir, F.jsxs = ur;\n  }()), F;\n}\nprocess.env.NODE_ENV === \"production\" ? Z.exports = lr() : Z.exports = cr();\nvar dr = Z.exports;\nexport {\n  dr as j\n};\n","var F = Object.defineProperty;\nvar c = (e, s, t) => s in e ? F(e, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[s] = t;\nvar i = (e, s, t) => c(e, typeof s != \"symbol\" ? s + \"\" : s, t);\nvar h = /* @__PURE__ */ ((e) => (e.FailedFetchSessionsActive = \"FailedFetchSessionsActive\", e.FailedFetchSessionsRefresh = \"FailedFetchSessionsRefresh\", e.FailedFetchSessionsLogout = \"FailedFetchSessionsLogout\", e))(h || {});\nclass a extends Error {\n  constructor(t, o) {\n    super(o);\n    i(this, \"type\");\n    this.name = t, this.type = t;\n  }\n}\nexport {\n  a as TMBError,\n  h as TMBErrorType\n};\n","import { TMBError as s, TMBErrorType as t } from \"./error.js\";\nimport { getServerInfo as o } from \"../constants/urls.js\";\nconst c = async () => {\n  const { serverUrl: r } = o();\n  try {\n    return await (await fetch(`https://${r}/oauth2/sessions/active`, {\n      method: \"GET\",\n      credentials: \"include\"\n    })).json();\n  } catch (e) {\n    throw console.error(\"unable to request sessions active: \", e), e instanceof Error ? new s(t.FailedFetchSessionsActive, e.message) : new s(t.FailedFetchSessionsActive, \"unable to request sessions active\");\n  }\n}, h = async () => {\n  const { serverUrl: r } = o();\n  try {\n    return await (await fetch(`https://${r}/oauth2/sessions/refresh`, {\n      method: \"POST\",\n      credentials: \"include\"\n    })).json();\n  } catch (e) {\n    throw console.error(\"unable to request sessions active: \", e), e instanceof Error ? new s(t.FailedFetchSessionsActive, e.message) : new s(t.FailedFetchSessionsActive, \"unable to request sessions active\");\n  }\n};\nexport {\n  c as requestSessionActive,\n  h as requestSessionRefresh\n};\n"],"names":["factory","module","exports","OldCookies","window","Cookies","api","noConflict","extend","i","result","arguments","length","attributes","key","decode","s","replace","decodeURIComponent","init","converter","set","value","document","path","defaults","expires","Date","toUTCString","JSON","stringify","test","e","write","encodeURIComponent","String","escape","stringifiedAttributes","attributeName","split","cookie","get","json","jar","cookies","parts","slice","join","charAt","name","read","parse","getJSON","remove","withConverter","derivP2pProduction","derivP2pStaging","location","origin","t","hostname","getAppId","n","l","g","getValue","configAppId","u","configServerURL","setValue","domainAppId","localStorage","getItem","includes","appId","lang","i18nLanguage","serverUrl","d","r","c","f","p","now","o","Object","create","v","withAttributes","this","freeze","defineProperty","Error","$","Ae","atob","charCodeAt","toString","toUpperCase","Oe","prototype","T","Ne","debug","info","warn","error","NONE","ERROR","WARN","INFO","DEBUG","reset","setLevel","setLogger","k","constructor","_name","_format","_method","createStatic","F","header","message","qe","generateSignedJwt","encodeBase64Url","TextEncoder","encode","crypto","subtle","sign","hash","Uint8Array","B","btoa","map","fromCharCode","de","b","_randomWord","Uint32Array","getRandomValues","generateUUIDv4","generateCodeVerifier","generateCodeChallenge","digest","generateBasicAuth","customCalculateJwkThumbprint","kty","crv","x","y","generateDPoPProof","url","accessToken","httpMethod","keyPair","nonce","a","jti","randomUUID","htm","htu","iat","Math","floor","ath","exportKey","publicKey","alg","typ","jwk","privateKey","TypeError","generateDPoPJkt","generateDPoPKeys","generateKey","namedCurve","P","_callbacks","_logger","addHandler","push","removeHandler","lastIndexOf","splice","raise","J","super","_timerHandle","_expiration","_callback","getEpochTime","cancel","max","expiration","min","setInterval","clearInterval","W","Y","id","data","created","request_type","url_state","toStorageString","fromStorageString","Promise","resolve","clearStaleState","getAllKeys","ue","Z","code_verifier","code_challenge","authority","client_id","redirect_uri","scope","client_secret","extraTokenParams","response_mode","skipUserInfo","_e","pe","state","response_type","state_data","resource","extraQueryParams","O","A","disablePKCE","q","dpopJkt","U","omitScopeWhenRequesting","C","N","_","URL","searchParams","append","I","Array","isArray","forEach","m","entries","href","M","Symbol","for","hasOwnProperty","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","ref","__self","__source","h","call","defaultProps","$$typeof","type","props","_owner","current","Fragment","jsx","jsxs","lr","enumerable","configurable","writable","FailedFetchSessionsActive","FailedFetchSessionsRefresh","FailedFetchSessionsLogout","async","fetch","method","credentials","console"],"sourceRoot":""}